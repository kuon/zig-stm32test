// this file was generated by regz: https://github.com/ZigEmbeddedGroup/regz
// commit: 328f6dcdd06e21a9c8fa2aa12371550b9ced8e2f
//
// device: STM32L0x1
// cpu: CM0+

pub const VectorTable = extern struct {
    initial_stack_pointer: u32,
    Reset: InterruptVector = unhandled,
    NMI: InterruptVector = unhandled,
    HardFault: InterruptVector = unhandled,
    reserved0: [7]u32 = undefined,
    SVCall: InterruptVector = unhandled,
    reserved1: [2]u32 = undefined,
    PendSV: InterruptVector = unhandled,
    SysTick: InterruptVector = unhandled,
    /// Window Watchdog interrupt
    WWDG: InterruptVector = unhandled,
    /// PVD through EXTI line detection
    PVD: InterruptVector = unhandled,
    /// RTC global interrupt
    RTC: InterruptVector = unhandled,
    /// Flash global interrupt
    FLASH: InterruptVector = unhandled,
    /// RCC global interrupt
    RCC: InterruptVector = unhandled,
    /// EXTI Line[1:0] interrupts
    EXTI0_1: InterruptVector = unhandled,
    /// EXTI Line[3:2] interrupts
    EXTI2_3: InterruptVector = unhandled,
    /// EXTI Line15 and EXTI4 interrupts
    EXTI4_15: InterruptVector = unhandled,
    reserved2: u32 = undefined,
    /// DMA1 Channel1 global interrupt
    DMA1_Channel1: InterruptVector = unhandled,
    /// DMA1 Channel2 and 3 interrupts
    DMA1_Channel2_3: InterruptVector = unhandled,
    /// DMA1 Channel4 to 7 interrupts
    DMA1_Channel4_7: InterruptVector = unhandled,
    /// ADC and comparator 1 and 2
    ADC_COMP: InterruptVector = unhandled,
    /// LPTIMER1 interrupt through
    /// EXTI29
    LPTIM1: InterruptVector = unhandled,
    /// USART4/USART5 global interrupt
    USART4_USART5: InterruptVector = unhandled,
    /// TIM2 global interrupt
    TIM2: InterruptVector = unhandled,
    /// TIM3 global interrupt
    TIM3: InterruptVector = unhandled,
    /// TIM6 global interrupt and DAC
    TIM6: InterruptVector = unhandled,
    /// TIM7 global interrupt and DAC
    TIM7: InterruptVector = unhandled,
    reserved3: u32 = undefined,
    /// TIMER21 global interrupt
    TIM21: InterruptVector = unhandled,
    /// I2C3 global interrupt
    I2C3: InterruptVector = unhandled,
    /// TIMER22 global interrupt
    TIM22: InterruptVector = unhandled,
    /// I2C1 global interrupt
    I2C1: InterruptVector = unhandled,
    /// I2C2 global interrupt
    I2C2: InterruptVector = unhandled,
    /// SPI1_global_interrupt
    SPI1: InterruptVector = unhandled,
    /// SPI2 global interrupt
    SPI2: InterruptVector = unhandled,
    /// USART1 global interrupt
    USART1: InterruptVector = unhandled,
    /// USART2 global interrupt
    USART2: InterruptVector = unhandled,
    /// AES global interrupt RNG global interrupt and
    /// LPUART1 global interrupt through
    AES_RNG_LPUART1: InterruptVector = unhandled,
};

pub const registers = struct {

    /// System Control Space
    pub const SCS = struct {
        pub const base_address = 0xe000e000;

        /// System Tick Timer
        pub const SysTick = struct {

            /// address: 0xe000e010
            /// SysTick Control and Status Register
            pub const CTRL = @intToPtr(*volatile Mmio(32, packed struct {
                ENABLE: u1,
                TICKINT: u1,
                CLKSOURCE: u1,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                COUNTFLAG: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
            }), base_address + 0x10);

            /// address: 0xe000e014
            /// SysTick Reload Value Register
            pub const LOAD = @intToPtr(*volatile Mmio(32, packed struct {
                RELOAD: u24,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
            }), base_address + 0x14);

            /// address: 0xe000e018
            /// SysTick Current Value Register
            pub const VAL = @intToPtr(*volatile Mmio(32, packed struct {
                CURRENT: u24,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
            }), base_address + 0x18);

            /// address: 0xe000e01c
            /// SysTick Calibration Register
            pub const CALIB = @intToPtr(*volatile Mmio(32, packed struct {
                TENMS: u24,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                SKEW: u1,
                NOREF: u1,
            }), base_address + 0x1c);
        };

        /// Nested Vectored Interrupt Controller
        pub const NVIC = struct {

            /// address: 0xe000e100
            /// Interrupt Set Enable Register
            pub const ISER = @intToPtr(*volatile u32, base_address + 0x100);

            /// address: 0xe000e180
            /// Interrupt Clear Enable Register
            pub const ICER = @intToPtr(*volatile u32, base_address + 0x180);

            /// address: 0xe000e200
            /// Interrupt Set Pending Register
            pub const ISPR = @intToPtr(*volatile u32, base_address + 0x200);

            /// address: 0xe000e280
            /// Interrupt Clear Pending Register
            pub const ICPR = @intToPtr(*volatile u32, base_address + 0x280);

            /// address: 0xe000e400
            /// Interrupt Priority Register
            pub const IP = @intToPtr(*volatile u32, base_address + 0x400);
        };

        /// System Control Block
        pub const SCB = struct {

            /// address: 0xe000ed00
            pub const CPUID = @intToPtr(*volatile Mmio(32, packed struct {
                REVISION: u4,
                PARTNO: u12,
                ARCHITECTURE: u4,
                VARIANT: u4,
                IMPLEMENTER: u8,
            }), base_address + 0xd00);

            /// address: 0xe000ed04
            /// Interrupt Control and State Register
            pub const ICSR = @intToPtr(*volatile Mmio(32, packed struct {
                VECTACTIVE: u9,
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                VECTPENDING: u9,
                reserved3: u1,
                ISRPENDING: u1,
                ISRPREEMPT: u1,
                reserved4: u1,
                PENDSTCLR: u1,
                PENDSTSET: u1,
                PENDSVCLR: u1,
                PENDSVSET: u1,
                reserved5: u1,
                reserved6: u1,
                NMIPENDSET: u1,
            }), base_address + 0xd04);

            /// address: 0xe000ed0c
            /// Application Interrupt and Reset Control Register
            pub const AIRCR = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1,
                VECTCLRACTIVE: u1,
                SYSRESETREQ: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                ENDIANESS: u1,
                VECTKEY: u16,
            }), base_address + 0xd0c);

            /// address: 0xe000ed10
            /// System Control Register
            pub const SCR = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1,
                SLEEPONEXIT: u1,
                SLEEPDEEP: u1,
                reserved1: u1,
                SEVONPEND: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
                padding22: u1,
                padding23: u1,
                padding24: u1,
                padding25: u1,
                padding26: u1,
            }), base_address + 0xd10);

            /// address: 0xe000ed14
            /// Configuration Control Register
            pub const CCR = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                UNALIGN_TRP: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                STKALIGN: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
                padding16: u1,
                padding17: u1,
                padding18: u1,
                padding19: u1,
                padding20: u1,
                padding21: u1,
            }), base_address + 0xd14);

            /// address: 0xe000ed1c
            /// System Handlers Priority Registers. [0] is RESERVED
            pub const SHP = @intToPtr(*volatile u32, base_address + 0xd1c);

            /// address: 0xe000ed24
            /// System Handler Control and State Register
            pub const SHCSR = @intToPtr(*volatile Mmio(32, packed struct {
                reserved0: u1,
                reserved1: u1,
                reserved2: u1,
                reserved3: u1,
                reserved4: u1,
                reserved5: u1,
                reserved6: u1,
                reserved7: u1,
                reserved8: u1,
                reserved9: u1,
                reserved10: u1,
                reserved11: u1,
                reserved12: u1,
                reserved13: u1,
                reserved14: u1,
                SVCALLPENDED: u1,
                padding0: u1,
                padding1: u1,
                padding2: u1,
                padding3: u1,
                padding4: u1,
                padding5: u1,
                padding6: u1,
                padding7: u1,
                padding8: u1,
                padding9: u1,
                padding10: u1,
                padding11: u1,
                padding12: u1,
                padding13: u1,
                padding14: u1,
                padding15: u1,
            }), base_address + 0xd24);
        };
    };

    /// Advanced encryption standard hardware
    /// accelerator
    pub const AES = struct {
        pub const base_address = 0x40026000;

        /// address: 0x40026000
        /// control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// AES enable
            EN: u1,
            /// Data type selection (for data in and
            /// data out to/from the cryptographic
            /// block)
            DATATYPE: u2,
            /// AES operating mode
            MODE: u2,
            /// AES chaining mode
            CHMOD: u2,
            /// Computation Complete Flag
            /// Clear
            CCFC: u1,
            /// Error clear
            ERRC: u1,
            /// CCF flag interrupt enable
            CCFIE: u1,
            /// Error interrupt enable
            ERRIE: u1,
            /// Enable DMA management of data input
            /// phase
            DMAINEN: u1,
            /// Enable DMA management of data output
            /// phase
            DMAOUTEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x0);

        /// address: 0x40026004
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Computation complete flag
            CCF: u1,
            /// Read error flag
            RDERR: u1,
            /// Write error flag
            WRERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x4);

        /// address: 0x40026008
        /// data input register
        pub const DINR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Input Register.
            AES_DINR: u32,
        }), base_address + 0x8);

        /// address: 0x4002600c
        /// data output register
        pub const DOUTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data output register
            AES_DOUTR: u32,
        }), base_address + 0xc);

        /// address: 0x40026010
        /// key register 0
        pub const KEYR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Data Output Register (LSB key
            /// [31:0])
            AES_KEYR0: u32,
        }), base_address + 0x10);

        /// address: 0x40026014
        /// key register 1
        pub const KEYR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// AES key register (key
            /// [63:32])
            AES_KEYR1: u32,
        }), base_address + 0x14);

        /// address: 0x40026018
        /// key register 2
        pub const KEYR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// AES key register (key
            /// [95:64])
            AES_KEYR2: u32,
        }), base_address + 0x18);

        /// address: 0x4002601c
        /// key register 3
        pub const KEYR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// AES key register (MSB key
            /// [127:96])
            AES_KEYR3: u32,
        }), base_address + 0x1c);

        /// address: 0x40026020
        /// initialization vector register
        /// 0
        pub const IVR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// initialization vector register (LSB IVR
            /// [31:0])
            AES_IVR0: u32,
        }), base_address + 0x20);

        /// address: 0x40026024
        /// initialization vector register
        /// 1
        pub const IVR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Initialization Vector Register (IVR
            /// [63:32])
            AES_IVR1: u32,
        }), base_address + 0x24);

        /// address: 0x40026028
        /// initialization vector register
        /// 2
        pub const IVR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Initialization Vector Register (IVR
            /// [95:64])
            AES_IVR2: u32,
        }), base_address + 0x28);

        /// address: 0x4002602c
        /// initialization vector register
        /// 3
        pub const IVR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Initialization Vector Register (MSB IVR
            /// [127:96])
            AES_IVR3: u32,
        }), base_address + 0x2c);
    };

    /// Direct memory access controller
    pub const DMA1 = struct {
        pub const base_address = 0x40020000;

        /// address: 0x40020000
        /// interrupt status register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel x global interrupt flag (x = 1
            /// ..7)
            GIF1: u1,
            /// Channel x transfer complete flag (x = 1
            /// ..7)
            TCIF1: u1,
            /// Channel x half transfer flag (x = 1
            /// ..7)
            HTIF1: u1,
            /// Channel x transfer error flag (x = 1
            /// ..7)
            TEIF1: u1,
            /// Channel x global interrupt flag (x = 1
            /// ..7)
            GIF2: u1,
            /// Channel x transfer complete flag (x = 1
            /// ..7)
            TCIF2: u1,
            /// Channel x half transfer flag (x = 1
            /// ..7)
            HTIF2: u1,
            /// Channel x transfer error flag (x = 1
            /// ..7)
            TEIF2: u1,
            /// Channel x global interrupt flag (x = 1
            /// ..7)
            GIF3: u1,
            /// Channel x transfer complete flag (x = 1
            /// ..7)
            TCIF3: u1,
            /// Channel x half transfer flag (x = 1
            /// ..7)
            HTIF3: u1,
            /// Channel x transfer error flag (x = 1
            /// ..7)
            TEIF3: u1,
            /// Channel x global interrupt flag (x = 1
            /// ..7)
            GIF4: u1,
            /// Channel x transfer complete flag (x = 1
            /// ..7)
            TCIF4: u1,
            /// Channel x half transfer flag (x = 1
            /// ..7)
            HTIF4: u1,
            /// Channel x transfer error flag (x = 1
            /// ..7)
            TEIF4: u1,
            /// Channel x global interrupt flag (x = 1
            /// ..7)
            GIF5: u1,
            /// Channel x transfer complete flag (x = 1
            /// ..7)
            TCIF5: u1,
            /// Channel x half transfer flag (x = 1
            /// ..7)
            HTIF5: u1,
            /// Channel x transfer error flag (x = 1
            /// ..7)
            TEIF5: u1,
            /// Channel x global interrupt flag (x = 1
            /// ..7)
            GIF6: u1,
            /// Channel x transfer complete flag (x = 1
            /// ..7)
            TCIF6: u1,
            /// Channel x half transfer flag (x = 1
            /// ..7)
            HTIF6: u1,
            /// Channel x transfer error flag (x = 1
            /// ..7)
            TEIF6: u1,
            /// Channel x global interrupt flag (x = 1
            /// ..7)
            GIF7: u1,
            /// Channel x transfer complete flag (x = 1
            /// ..7)
            TCIF7: u1,
            /// Channel x half transfer flag (x = 1
            /// ..7)
            HTIF7: u1,
            /// Channel x transfer error flag (x = 1
            /// ..7)
            TEIF7: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x0);

        /// address: 0x40020004
        /// interrupt flag clear register
        pub const IFCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel x global interrupt clear (x = 1
            /// ..7)
            CGIF1: u1,
            /// Channel x transfer complete clear (x = 1
            /// ..7)
            CTCIF1: u1,
            /// Channel x half transfer clear (x = 1
            /// ..7)
            CHTIF1: u1,
            /// Channel x transfer error clear (x = 1
            /// ..7)
            CTEIF1: u1,
            /// Channel x global interrupt clear (x = 1
            /// ..7)
            CGIF2: u1,
            /// Channel x transfer complete clear (x = 1
            /// ..7)
            CTCIF2: u1,
            /// Channel x half transfer clear (x = 1
            /// ..7)
            CHTIF2: u1,
            /// Channel x transfer error clear (x = 1
            /// ..7)
            CTEIF2: u1,
            /// Channel x global interrupt clear (x = 1
            /// ..7)
            CGIF3: u1,
            /// Channel x transfer complete clear (x = 1
            /// ..7)
            CTCIF3: u1,
            /// Channel x half transfer clear (x = 1
            /// ..7)
            CHTIF3: u1,
            /// Channel x transfer error clear (x = 1
            /// ..7)
            CTEIF3: u1,
            /// Channel x global interrupt clear (x = 1
            /// ..7)
            CGIF4: u1,
            /// Channel x transfer complete clear (x = 1
            /// ..7)
            CTCIF4: u1,
            /// Channel x half transfer clear (x = 1
            /// ..7)
            CHTIF4: u1,
            /// Channel x transfer error clear (x = 1
            /// ..7)
            CTEIF4: u1,
            /// Channel x global interrupt clear (x = 1
            /// ..7)
            CGIF5: u1,
            /// Channel x transfer complete clear (x = 1
            /// ..7)
            CTCIF5: u1,
            /// Channel x half transfer clear (x = 1
            /// ..7)
            CHTIF5: u1,
            /// Channel x transfer error clear (x = 1
            /// ..7)
            CTEIF5: u1,
            /// Channel x global interrupt clear (x = 1
            /// ..7)
            CGIF6: u1,
            /// Channel x transfer complete clear (x = 1
            /// ..7)
            CTCIF6: u1,
            /// Channel x half transfer clear (x = 1
            /// ..7)
            CHTIF6: u1,
            /// Channel x transfer error clear (x = 1
            /// ..7)
            CTEIF6: u1,
            /// Channel x global interrupt clear (x = 1
            /// ..7)
            CGIF7: u1,
            /// Channel x transfer complete clear (x = 1
            /// ..7)
            CTCIF7: u1,
            /// Channel x half transfer clear (x = 1
            /// ..7)
            CHTIF7: u1,
            /// Channel x transfer error clear (x = 1
            /// ..7)
            CTEIF7: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x4);

        /// address: 0x40020008
        /// channel x configuration
        /// register
        pub const CCR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x8);

        /// address: 0x4002000c
        /// channel x number of data
        /// register
        pub const CNDTR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40020010
        /// channel x peripheral address
        /// register
        pub const CPAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x10);

        /// address: 0x40020014
        /// channel x memory address
        /// register
        pub const CMAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x14);

        /// address: 0x4002001c
        /// channel x configuration
        /// register
        pub const CCR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x1c);

        /// address: 0x40020020
        /// channel x number of data
        /// register
        pub const CNDTR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x20);

        /// address: 0x40020024
        /// channel x peripheral address
        /// register
        pub const CPAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x24);

        /// address: 0x40020028
        /// channel x memory address
        /// register
        pub const CMAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x28);

        /// address: 0x40020030
        /// channel x configuration
        /// register
        pub const CCR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x30);

        /// address: 0x40020034
        /// channel x number of data
        /// register
        pub const CNDTR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x34);

        /// address: 0x40020038
        /// channel x peripheral address
        /// register
        pub const CPAR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x38);

        /// address: 0x4002003c
        /// channel x memory address
        /// register
        pub const CMAR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x3c);

        /// address: 0x40020044
        /// channel x configuration
        /// register
        pub const CCR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x44);

        /// address: 0x40020048
        /// channel x number of data
        /// register
        pub const CNDTR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x48);

        /// address: 0x4002004c
        /// channel x peripheral address
        /// register
        pub const CPAR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x4c);

        /// address: 0x40020050
        /// channel x memory address
        /// register
        pub const CMAR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x50);

        /// address: 0x40020058
        /// channel x configuration
        /// register
        pub const CCR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x58);

        /// address: 0x4002005c
        /// channel x number of data
        /// register
        pub const CNDTR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x5c);

        /// address: 0x40020060
        /// channel x peripheral address
        /// register
        pub const CPAR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x60);

        /// address: 0x40020064
        /// channel x memory address
        /// register
        pub const CMAR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x64);

        /// address: 0x4002006c
        /// channel x configuration
        /// register
        pub const CCR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x6c);

        /// address: 0x40020070
        /// channel x number of data
        /// register
        pub const CNDTR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x70);

        /// address: 0x40020074
        /// channel x peripheral address
        /// register
        pub const CPAR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x74);

        /// address: 0x40020078
        /// channel x memory address
        /// register
        pub const CMAR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x78);

        /// address: 0x40020080
        /// channel x configuration
        /// register
        pub const CCR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel enable
            EN: u1,
            /// Transfer complete interrupt
            /// enable
            TCIE: u1,
            /// Half transfer interrupt
            /// enable
            HTIE: u1,
            /// Transfer error interrupt
            /// enable
            TEIE: u1,
            /// Data transfer direction
            DIR: u1,
            /// Circular mode
            CIRC: u1,
            /// Peripheral increment mode
            PINC: u1,
            /// Memory increment mode
            MINC: u1,
            /// Peripheral size
            PSIZE: u2,
            /// Memory size
            MSIZE: u2,
            /// Channel priority level
            PL: u2,
            /// Memory to memory mode
            MEM2MEM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x80);

        /// address: 0x40020084
        /// channel x number of data
        /// register
        pub const CNDTR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Number of data to transfer
            NDT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x84);

        /// address: 0x40020088
        /// channel x peripheral address
        /// register
        pub const CPAR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral address
            PA: u32,
        }), base_address + 0x88);

        /// address: 0x4002008c
        /// channel x memory address
        /// register
        pub const CMAR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory address
            MA: u32,
        }), base_address + 0x8c);

        /// address: 0x400200a8
        /// channel selection register
        pub const CSELR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA channel 1 selection
            C1S: u4,
            /// DMA channel 2 selection
            C2S: u4,
            /// DMA channel 3 selection
            C3S: u4,
            /// DMA channel 4 selection
            C4S: u4,
            /// DMA channel 5 selection
            C5S: u4,
            /// DMA channel 6 selection
            C6S: u4,
            /// DMA channel 7 selection
            C7S: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0xa8);
    };

    /// Cyclic redundancy check calculation
    /// unit
    pub const CRC = struct {
        pub const base_address = 0x40023000;

        /// address: 0x40023000
        /// Data register
        pub const DR = @intToPtr(*volatile u32, base_address + 0x0);

        /// address: 0x40023004
        /// Independent data register
        pub const IDR = @intToPtr(*volatile MmioInt(32, u8), base_address + 0x4);

        /// address: 0x40023008
        /// Control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// RESET bit
            RESET: u1,
            reserved0: u1,
            reserved1: u1,
            /// Polynomial size
            POLYSIZE: u2,
            /// Reverse input data
            REV_IN: u2,
            /// Reverse output data
            REV_OUT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0x40023010
        /// Initial CRC value
        pub const INIT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Programmable initial CRC
            /// value
            CRC_INIT: u32,
        }), base_address + 0x10);

        /// address: 0x40023014
        /// polynomial
        pub const POL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Programmable polynomial
            Polynomialcoefficients: u32,
        }), base_address + 0x14);
    };

    /// General-purpose I/Os
    pub const GPIOA = struct {
        pub const base_address = 0x50000000;

        /// address: 0x50000000
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODE0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE15: u2,
        }), base_address + 0x0);

        /// address: 0x50000004
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OT0: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT1: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT2: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT3: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT4: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT5: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT6: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT7: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT8: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT9: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT10: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT11: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT12: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT13: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT14: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x50000008
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED15: u2,
        }), base_address + 0x8);

        /// address: 0x5000000c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD15: u2,
        }), base_address + 0xc);

        /// address: 0x50000010
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data bit (y =
            /// 0..15)
            ID0: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID1: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID2: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID3: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID4: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID5: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID6: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID7: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID8: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID9: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID10: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID11: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID12: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID13: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID14: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x50000014
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data bit (y =
            /// 0..15)
            OD0: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD1: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD2: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD3: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD4: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD5: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD6: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD7: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD8: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD9: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD10: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD11: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD12: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD13: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD14: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x50000018
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x5000001c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x50000020
        /// GPIO alternate function low
        /// register
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL0: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL1: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL2: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL3: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL4: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL5: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL6: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL7: u4,
        }), base_address + 0x20);

        /// address: 0x50000024
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL8: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL9: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL10: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL11: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL12: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL13: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL14: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL15: u4,
        }), base_address + 0x24);

        /// address: 0x50000028
        /// GPIO port bit reset register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR0: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR1: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR2: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR3: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR4: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR5: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR6: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR7: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR8: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR9: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR10: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR11: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR12: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR13: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR14: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);
    };

    /// General-purpose I/Os
    pub const GPIOB = struct {
        pub const base_address = 0x50000400;

        /// address: 0x50000400
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODE0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE15: u2,
        }), base_address + 0x0);

        /// address: 0x50000404
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OT0: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT1: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT2: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT3: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT4: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT5: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT6: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT7: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT8: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT9: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT10: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT11: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT12: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT13: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT14: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x50000408
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED15: u2,
        }), base_address + 0x8);

        /// address: 0x5000040c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD15: u2,
        }), base_address + 0xc);

        /// address: 0x50000410
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data bit (y =
            /// 0..15)
            ID0: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID1: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID2: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID3: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID4: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID5: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID6: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID7: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID8: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID9: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID10: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID11: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID12: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID13: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID14: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x50000414
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data bit (y =
            /// 0..15)
            OD0: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD1: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD2: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD3: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD4: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD5: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD6: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD7: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD8: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD9: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD10: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD11: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD12: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD13: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD14: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x50000418
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x5000041c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x50000420
        /// GPIO alternate function low
        /// register
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL0: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL1: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL2: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL3: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL4: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL5: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL6: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL7: u4,
        }), base_address + 0x20);

        /// address: 0x50000424
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL8: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL9: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL10: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL11: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL12: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL13: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL14: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL15: u4,
        }), base_address + 0x24);

        /// address: 0x50000428
        /// GPIO port bit reset register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR0: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR1: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR2: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR3: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR4: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR5: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR6: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR7: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR8: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR9: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR10: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR11: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR12: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR13: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR14: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);
    };
    pub const GPIOC = struct {
        pub const base_address = 0x50000800;

        /// address: 0x50000800
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODE0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE15: u2,
        }), base_address + 0x0);

        /// address: 0x50000804
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OT0: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT1: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT2: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT3: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT4: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT5: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT6: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT7: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT8: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT9: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT10: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT11: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT12: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT13: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT14: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x50000808
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED15: u2,
        }), base_address + 0x8);

        /// address: 0x5000080c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD15: u2,
        }), base_address + 0xc);

        /// address: 0x50000810
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data bit (y =
            /// 0..15)
            ID0: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID1: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID2: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID3: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID4: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID5: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID6: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID7: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID8: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID9: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID10: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID11: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID12: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID13: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID14: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x50000814
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data bit (y =
            /// 0..15)
            OD0: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD1: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD2: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD3: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD4: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD5: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD6: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD7: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD8: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD9: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD10: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD11: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD12: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD13: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD14: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x50000818
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x5000081c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x50000820
        /// GPIO alternate function low
        /// register
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL0: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL1: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL2: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL3: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL4: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL5: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL6: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL7: u4,
        }), base_address + 0x20);

        /// address: 0x50000824
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL8: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL9: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL10: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL11: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL12: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL13: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL14: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL15: u4,
        }), base_address + 0x24);

        /// address: 0x50000828
        /// GPIO port bit reset register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR0: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR1: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR2: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR3: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR4: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR5: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR6: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR7: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR8: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR9: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR10: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR11: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR12: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR13: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR14: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);
    };
    pub const GPIOD = struct {
        pub const base_address = 0x50000c00;

        /// address: 0x50000c00
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODE0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE15: u2,
        }), base_address + 0x0);

        /// address: 0x50000c04
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OT0: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT1: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT2: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT3: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT4: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT5: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT6: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT7: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT8: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT9: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT10: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT11: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT12: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT13: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT14: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x50000c08
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED15: u2,
        }), base_address + 0x8);

        /// address: 0x50000c0c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD15: u2,
        }), base_address + 0xc);

        /// address: 0x50000c10
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data bit (y =
            /// 0..15)
            ID0: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID1: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID2: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID3: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID4: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID5: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID6: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID7: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID8: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID9: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID10: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID11: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID12: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID13: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID14: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x50000c14
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data bit (y =
            /// 0..15)
            OD0: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD1: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD2: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD3: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD4: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD5: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD6: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD7: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD8: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD9: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD10: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD11: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD12: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD13: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD14: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x50000c18
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x50000c1c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x50000c20
        /// GPIO alternate function low
        /// register
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL0: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL1: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL2: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL3: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL4: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL5: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL6: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL7: u4,
        }), base_address + 0x20);

        /// address: 0x50000c24
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL8: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL9: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL10: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL11: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL12: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL13: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL14: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL15: u4,
        }), base_address + 0x24);

        /// address: 0x50000c28
        /// GPIO port bit reset register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR0: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR1: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR2: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR3: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR4: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR5: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR6: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR7: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR8: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR9: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR10: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR11: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR12: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR13: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR14: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);
    };
    pub const GPIOH = struct {
        pub const base_address = 0x50001c00;

        /// address: 0x50001c00
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODE0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE15: u2,
        }), base_address + 0x0);

        /// address: 0x50001c04
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OT0: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT1: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT2: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT3: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT4: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT5: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT6: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT7: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT8: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT9: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT10: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT11: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT12: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT13: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT14: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x50001c08
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED15: u2,
        }), base_address + 0x8);

        /// address: 0x50001c0c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD15: u2,
        }), base_address + 0xc);

        /// address: 0x50001c10
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data bit (y =
            /// 0..15)
            ID0: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID1: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID2: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID3: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID4: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID5: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID6: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID7: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID8: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID9: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID10: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID11: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID12: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID13: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID14: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x50001c14
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data bit (y =
            /// 0..15)
            OD0: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD1: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD2: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD3: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD4: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD5: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD6: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD7: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD8: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD9: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD10: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD11: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD12: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD13: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD14: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x50001c18
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x50001c1c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x50001c20
        /// GPIO alternate function low
        /// register
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL0: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL1: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL2: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL3: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL4: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL5: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL6: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL7: u4,
        }), base_address + 0x20);

        /// address: 0x50001c24
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL8: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL9: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL10: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL11: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL12: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL13: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL14: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL15: u4,
        }), base_address + 0x24);

        /// address: 0x50001c28
        /// GPIO port bit reset register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR0: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR1: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR2: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR3: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR4: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR5: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR6: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR7: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR8: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR9: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR10: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR11: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR12: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR13: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR14: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);
    };
    pub const GPIOE = struct {
        pub const base_address = 0x50001000;

        /// address: 0x50001000
        /// GPIO port mode register
        pub const MODER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            MODE0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            MODE15: u2,
        }), base_address + 0x0);

        /// address: 0x50001004
        /// GPIO port output type register
        pub const OTYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OT0: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT1: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT2: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT3: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT4: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT5: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT6: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT7: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT8: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT9: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT10: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT11: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT12: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT13: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT14: u1,
            /// Port x configuration bits (y =
            /// 0..15)
            OT15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4);

        /// address: 0x50001008
        /// GPIO port output speed
        /// register
        pub const OSPEEDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            OSPEED15: u2,
        }), base_address + 0x8);

        /// address: 0x5000100c
        /// GPIO port pull-up/pull-down
        /// register
        pub const PUPDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD0: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD1: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD2: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD3: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD4: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD5: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD6: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD7: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD8: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD9: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD10: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD11: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD12: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD13: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD14: u2,
            /// Port x configuration bits (y =
            /// 0..15)
            PUPD15: u2,
        }), base_address + 0xc);

        /// address: 0x50001010
        /// GPIO port input data register
        pub const IDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port input data bit (y =
            /// 0..15)
            ID0: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID1: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID2: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID3: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID4: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID5: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID6: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID7: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID8: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID9: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID10: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID11: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID12: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID13: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID14: u1,
            /// Port input data bit (y =
            /// 0..15)
            ID15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x50001014
        /// GPIO port output data register
        pub const ODR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port output data bit (y =
            /// 0..15)
            OD0: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD1: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD2: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD3: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD4: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD5: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD6: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD7: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD8: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD9: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD10: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD11: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD12: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD13: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD14: u1,
            /// Port output data bit (y =
            /// 0..15)
            OD15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x50001018
        /// GPIO port bit set/reset
        /// register
        pub const BSRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x set bit y (y=
            /// 0..15)
            BS0: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS1: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS2: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS3: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS4: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS5: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS6: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS7: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS8: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS9: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS10: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS11: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS12: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS13: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS14: u1,
            /// Port x set bit y (y=
            /// 0..15)
            BS15: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR0: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR1: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR2: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR3: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR4: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR5: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR6: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR7: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR8: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR9: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR10: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR11: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR12: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR13: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR14: u1,
            /// Port x reset bit y (y =
            /// 0..15)
            BR15: u1,
        }), base_address + 0x18);

        /// address: 0x5000101c
        /// GPIO port configuration lock
        /// register
        pub const LCKR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x lock bit y (y=
            /// 0..15)
            LCK0: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK1: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK2: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK3: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK4: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK5: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK6: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK7: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK8: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK9: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK10: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK11: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK12: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK13: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK14: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCK15: u1,
            /// Port x lock bit y (y=
            /// 0..15)
            LCKK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x1c);

        /// address: 0x50001020
        /// GPIO alternate function low
        /// register
        pub const AFRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL0: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL1: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL2: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL3: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL4: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL5: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL6: u4,
            /// Alternate function selection for port x
            /// pin y (y = 0..7)
            AFSEL7: u4,
        }), base_address + 0x20);

        /// address: 0x50001024
        /// GPIO alternate function high
        /// register
        pub const AFRH = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL8: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL9: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL10: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL11: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL12: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL13: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL14: u4,
            /// Alternate function selection for port x
            /// pin y (y = 8..15)
            AFSEL15: u4,
        }), base_address + 0x24);

        /// address: 0x50001028
        /// GPIO port bit reset register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR0: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR1: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR2: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR3: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR4: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR5: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR6: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR7: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR8: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR9: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR10: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR11: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR12: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR13: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR14: u1,
            /// Port x Reset bit y (y= 0 ..
            /// 15)
            BR15: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);
    };

    /// Low power timer
    pub const LPTIM = struct {
        pub const base_address = 0x40007c00;

        /// address: 0x40007c00
        /// Interrupt and Status Register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Compare match
            CMPM: u1,
            /// Autoreload match
            ARRM: u1,
            /// External trigger edge
            /// event
            EXTTRIG: u1,
            /// Compare register update OK
            CMPOK: u1,
            /// Autoreload register update
            /// OK
            ARROK: u1,
            /// Counter direction change down to
            /// up
            UP: u1,
            /// Counter direction change up to
            /// down
            DOWN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x0);

        /// address: 0x40007c04
        /// Interrupt Clear Register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// compare match Clear Flag
            CMPMCF: u1,
            /// Autoreload match Clear
            /// Flag
            ARRMCF: u1,
            /// External trigger valid edge Clear
            /// Flag
            EXTTRIGCF: u1,
            /// Compare register update OK Clear
            /// Flag
            CMPOKCF: u1,
            /// Autoreload register update OK Clear
            /// Flag
            ARROKCF: u1,
            /// Direction change to UP Clear
            /// Flag
            UPCF: u1,
            /// Direction change to down Clear
            /// Flag
            DOWNCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x4);

        /// address: 0x40007c08
        /// Interrupt Enable Register
        pub const IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Compare match Interrupt
            /// Enable
            CMPMIE: u1,
            /// Autoreload match Interrupt
            /// Enable
            ARRMIE: u1,
            /// External trigger valid edge Interrupt
            /// Enable
            EXTTRIGIE: u1,
            /// Compare register update OK Interrupt
            /// Enable
            CMPOKIE: u1,
            /// Autoreload register update OK Interrupt
            /// Enable
            ARROKIE: u1,
            /// Direction change to UP Interrupt
            /// Enable
            UPIE: u1,
            /// Direction change to down Interrupt
            /// Enable
            DOWNIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x8);

        /// address: 0x40007c0c
        /// Configuration Register
        pub const CFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock selector
            CKSEL: u1,
            /// Clock Polarity
            CKPOL: u2,
            /// Configurable digital filter for external
            /// clock
            CKFLT: u2,
            reserved0: u1,
            /// Configurable digital filter for
            /// trigger
            TRGFLT: u2,
            reserved1: u1,
            /// Clock prescaler
            PRESC: u3,
            reserved2: u1,
            /// Trigger selector
            TRIGSEL: u3,
            reserved3: u1,
            /// Trigger enable and
            /// polarity
            TRIGEN: u2,
            /// Timeout enable
            TIMOUT: u1,
            /// Waveform shape
            WAVE: u1,
            /// Waveform shape polarity
            WAVPOL: u1,
            /// Registers update mode
            PRELOAD: u1,
            /// counter mode enabled
            COUNTMODE: u1,
            /// Encoder mode enable
            ENC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0xc);

        /// address: 0x40007c10
        /// Control Register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// LPTIM Enable
            ENABLE: u1,
            /// LPTIM start in single mode
            SNGSTRT: u1,
            /// Timer start in continuous
            /// mode
            CNTSTRT: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x10);

        /// address: 0x40007c14
        /// Compare Register
        pub const CMP = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x14);

        /// address: 0x40007c18
        /// Autoreload Register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x18);

        /// address: 0x40007c1c
        /// Counter Register
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x1c);
    };

    /// Real-time clock
    pub const RTC = struct {
        pub const base_address = 0x40002800;

        /// address: 0x40002800
        /// RTC time register
        pub const TR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Second units in BCD format
            SU: u4,
            /// Second tens in BCD format
            ST: u3,
            reserved0: u1,
            /// Minute units in BCD format
            MNU: u4,
            /// Minute tens in BCD format
            MNT: u3,
            reserved1: u1,
            /// Hour units in BCD format
            HU: u4,
            /// Hour tens in BCD format
            HT: u2,
            /// AM/PM notation
            PM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x0);

        /// address: 0x40002804
        /// RTC date register
        pub const DR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Date units in BCD format
            DU: u4,
            /// Date tens in BCD format
            DT: u2,
            reserved0: u1,
            reserved1: u1,
            /// Month units in BCD format
            MU: u4,
            /// Month tens in BCD format
            MT: u1,
            /// Week day units
            WDU: u3,
            /// Year units in BCD format
            YU: u4,
            /// Year tens in BCD format
            YT: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x4);

        /// address: 0x40002808
        /// RTC control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Wakeup clock selection
            WUCKSEL: u3,
            /// Time-stamp event active
            /// edge
            TSEDGE: u1,
            /// RTC_REFIN reference clock detection
            /// enable (50 or 60 Hz)
            REFCKON: u1,
            /// Bypass the shadow
            /// registers
            BYPSHAD: u1,
            /// Hour format
            FMT: u1,
            reserved0: u1,
            /// Alarm A enable
            ALRAE: u1,
            /// Alarm B enable
            ALRBE: u1,
            /// Wakeup timer enable
            WUTE: u1,
            /// timestamp enable
            TSE: u1,
            /// Alarm A interrupt enable
            ALRAIE: u1,
            /// Alarm B interrupt enable
            ALRBIE: u1,
            /// Wakeup timer interrupt
            /// enable
            WUTIE: u1,
            /// Time-stamp interrupt
            /// enable
            TSIE: u1,
            /// Add 1 hour (summer time
            /// change)
            ADD1H: u1,
            /// Subtract 1 hour (winter time
            /// change)
            SUB1H: u1,
            /// Backup
            BKP: u1,
            /// Calibration output
            /// selection
            COSEL: u1,
            /// Output polarity
            POL: u1,
            /// Output selection
            OSEL: u2,
            /// Calibration output enable
            COE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x8);

        /// address: 0x4000280c
        /// RTC initialization and status
        /// register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Alarm A write flag
            ALRAWF: u1,
            /// Alarm B write flag
            ALRBWF: u1,
            /// Wakeup timer write flag
            WUTWF: u1,
            /// Shift operation pending
            SHPF: u1,
            /// Initialization status flag
            INITS: u1,
            /// Registers synchronization
            /// flag
            RSF: u1,
            /// Initialization flag
            INITF: u1,
            /// Initialization mode
            INIT: u1,
            /// Alarm A flag
            ALRAF: u1,
            /// Alarm B flag
            ALRBF: u1,
            /// Wakeup timer flag
            WUTF: u1,
            /// Time-stamp flag
            TSF: u1,
            /// Time-stamp overflow flag
            TSOVF: u1,
            /// RTC_TAMP1 detection flag
            TAMP1F: u1,
            /// RTC_TAMP2 detection flag
            TAMP2F: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40002810
        /// RTC prescaler register
        pub const PRER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Synchronous prescaler
            /// factor
            PREDIV_S: u16,
            /// Asynchronous prescaler
            /// factor
            PREDIV_A: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x10);

        /// address: 0x40002814
        /// RTC wakeup timer register
        pub const WUTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Wakeup auto-reload value
            /// bits
            WUT: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x4000281c
        /// RTC alarm A register
        pub const ALRMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Second units in BCD
            /// format.
            SU: u4,
            /// Second tens in BCD format.
            ST: u3,
            /// Alarm A seconds mask
            MSK1: u1,
            /// Minute units in BCD
            /// format.
            MNU: u4,
            /// Minute tens in BCD format.
            MNT: u3,
            /// Alarm A minutes mask
            MSK2: u1,
            /// Hour units in BCD format.
            HU: u4,
            /// Hour tens in BCD format.
            HT: u2,
            /// AM/PM notation
            PM: u1,
            /// Alarm A hours mask
            MSK3: u1,
            /// Date units or day in BCD
            /// format.
            DU: u4,
            /// Date tens in BCD format.
            DT: u2,
            /// Week day selection
            WDSEL: u1,
            /// Alarm A date mask
            MSK4: u1,
        }), base_address + 0x1c);

        /// address: 0x40002820
        /// RTC alarm B register
        pub const ALRMBR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Second units in BCD format
            SU: u4,
            /// Second tens in BCD format
            ST: u3,
            /// Alarm B seconds mask
            MSK1: u1,
            /// Minute units in BCD format
            MNU: u4,
            /// Minute tens in BCD format
            MNT: u3,
            /// Alarm B minutes mask
            MSK2: u1,
            /// Hour units in BCD format
            HU: u4,
            /// Hour tens in BCD format
            HT: u2,
            /// AM/PM notation
            PM: u1,
            /// Alarm B hours mask
            MSK3: u1,
            /// Date units or day in BCD
            /// format
            DU: u4,
            /// Date tens in BCD format
            DT: u2,
            /// Week day selection
            WDSEL: u1,
            /// Alarm B date mask
            MSK4: u1,
        }), base_address + 0x20);

        /// address: 0x40002824
        /// write protection register
        pub const WPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write protection key
            KEY: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x24);

        /// address: 0x40002828
        /// RTC sub second register
        pub const SSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sub second value
            SS: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x28);

        /// address: 0x4000282c
        /// RTC shift control register
        pub const SHIFTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Subtract a fraction of a
            /// second
            SUBFS: u15,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Add one second
            ADD1S: u1,
        }), base_address + 0x2c);

        /// address: 0x40002830
        /// RTC timestamp time register
        pub const TSTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Second units in BCD
            /// format.
            SU: u4,
            /// Second tens in BCD format.
            ST: u3,
            reserved0: u1,
            /// Minute units in BCD
            /// format.
            MNU: u4,
            /// Minute tens in BCD format.
            MNT: u3,
            reserved1: u1,
            /// Hour units in BCD format.
            HU: u4,
            /// Hour tens in BCD format.
            HT: u2,
            /// AM/PM notation
            PM: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x30);

        /// address: 0x40002834
        /// RTC timestamp date register
        pub const TSDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Date units in BCD format
            DU: u4,
            /// Date tens in BCD format
            DT: u2,
            reserved0: u1,
            reserved1: u1,
            /// Month units in BCD format
            MU: u4,
            /// Month tens in BCD format
            MT: u1,
            /// Week day units
            WDU: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x34);

        /// address: 0x40002838
        /// RTC time-stamp sub second
        /// register
        pub const TSSSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sub second value
            SS: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x38);

        /// address: 0x4000283c
        /// RTC calibration register
        pub const CALR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Calibration minus
            CALM: u9,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Use a 16-second calibration cycle
            /// period
            CALW16: u1,
            /// Use an 8-second calibration cycle
            /// period
            CALW8: u1,
            /// Increase frequency of RTC by 488.5
            /// ppm
            CALP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x3c);

        /// address: 0x40002840
        /// RTC tamper configuration
        /// register
        pub const TAMPCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// RTC_TAMP1 input detection
            /// enable
            TAMP1E: u1,
            /// Active level for RTC_TAMP1
            /// input
            TAMP1TRG: u1,
            /// Tamper interrupt enable
            TAMPIE: u1,
            /// RTC_TAMP2 input detection
            /// enable
            TAMP2E: u1,
            /// Active level for RTC_TAMP2
            /// input
            TAMP2_TRG: u1,
            reserved0: u1,
            reserved1: u1,
            /// Activate timestamp on tamper detection
            /// event
            TAMPTS: u1,
            /// Tamper sampling frequency
            TAMPFREQ: u3,
            /// RTC_TAMPx filter count
            TAMPFLT: u2,
            /// RTC_TAMPx precharge
            /// duration
            TAMPPRCH: u2,
            /// RTC_TAMPx pull-up disable
            TAMPPUDIS: u1,
            /// Tamper 1 interrupt enable
            TAMP1IE: u1,
            /// Tamper 1 no erase
            TAMP1NOERASE: u1,
            /// Tamper 1 mask flag
            TAMP1MF: u1,
            /// Tamper 2 interrupt enable
            TAMP2IE: u1,
            /// Tamper 2 no erase
            TAMP2NOERASE: u1,
            /// Tamper 2 mask flag
            TAMP2MF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x40);

        /// address: 0x40002844
        /// RTC alarm A sub second
        /// register
        pub const ALRMASSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sub seconds value
            SS: u15,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Mask the most-significant bits starting
            /// at this bit
            MASKSS: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x44);

        /// address: 0x40002848
        /// RTC alarm B sub second
        /// register
        pub const ALRMBSSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Sub seconds value
            SS: u15,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Mask the most-significant bits starting
            /// at this bit
            MASKSS: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x48);

        /// address: 0x4000284c
        /// option register
        pub const OR = @intToPtr(*volatile Mmio(32, packed struct {
            /// RTC_ALARM on PC13 output
            /// type
            RTC_ALARM_TYPE: u1,
            /// RTC_ALARM on PC13 output
            /// type
            RTC_OUT_RMP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
        }), base_address + 0x4c);

        /// address: 0x40002850
        /// RTC backup registers
        pub const BKP0R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x50);

        /// address: 0x40002854
        /// RTC backup registers
        pub const BKP1R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x54);

        /// address: 0x40002858
        /// RTC backup registers
        pub const BKP2R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x58);

        /// address: 0x4000285c
        /// RTC backup registers
        pub const BKP3R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x5c);

        /// address: 0x40002860
        /// RTC backup registers
        pub const BKP4R = @intToPtr(*volatile Mmio(32, packed struct {
            /// BKP
            BKP: u32,
        }), base_address + 0x60);
    };

    /// Universal synchronous asynchronous receiver
    /// transmitter
    pub const USART1 = struct {
        pub const base_address = 0x40013800;

        /// address: 0x40013800
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// USART enable
            UE: u1,
            /// USART enable in Stop mode
            UESM: u1,
            /// Receiver enable
            RE: u1,
            /// Transmitter enable
            TE: u1,
            /// IDLE interrupt enable
            IDLEIE: u1,
            /// RXNE interrupt enable
            RXNEIE: u1,
            /// Transmission complete interrupt
            /// enable
            TCIE: u1,
            /// interrupt enable
            TXEIE: u1,
            /// PE interrupt enable
            PEIE: u1,
            /// Parity selection
            PS: u1,
            /// Parity control enable
            PCE: u1,
            /// Receiver wakeup method
            WAKE: u1,
            /// Word length
            M0: u1,
            /// Mute mode enable
            MME: u1,
            /// Character match interrupt
            /// enable
            CMIE: u1,
            /// Oversampling mode
            OVER8: u1,
            /// DEDT0
            DEDT0: u1,
            /// DEDT1
            DEDT1: u1,
            /// DEDT2
            DEDT2: u1,
            /// DEDT3
            DEDT3: u1,
            /// Driver Enable de-assertion
            /// time
            DEDT4: u1,
            /// DEAT0
            DEAT0: u1,
            /// DEAT1
            DEAT1: u1,
            /// DEAT2
            DEAT2: u1,
            /// DEAT3
            DEAT3: u1,
            /// Driver Enable assertion
            /// time
            DEAT4: u1,
            /// Receiver timeout interrupt
            /// enable
            RTOIE: u1,
            /// End of Block interrupt
            /// enable
            EOBIE: u1,
            /// Word length
            M1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x0);

        /// address: 0x40013804
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// 7-bit Address Detection/4-bit Address
            /// Detection
            ADDM7: u1,
            /// LIN break detection length
            LBDL: u1,
            /// LIN break detection interrupt
            /// enable
            LBDIE: u1,
            reserved4: u1,
            /// Last bit clock pulse
            LBCL: u1,
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Clock enable
            CLKEN: u1,
            /// STOP bits
            STOP: u2,
            /// LIN mode enable
            LINEN: u1,
            /// Swap TX/RX pins
            SWAP: u1,
            /// RX pin active level
            /// inversion
            RXINV: u1,
            /// TX pin active level
            /// inversion
            TXINV: u1,
            /// Binary data inversion
            TAINV: u1,
            /// Most significant bit first
            MSBFIRST: u1,
            /// Auto baud rate enable
            ABREN: u1,
            /// ABRMOD0
            ABRMOD0: u1,
            /// Auto baud rate mode
            ABRMOD1: u1,
            /// Receiver timeout enable
            RTOEN: u1,
            /// Address of the USART node
            ADD0_3: u4,
            /// Address of the USART node
            ADD4_7: u4,
        }), base_address + 0x4);

        /// address: 0x40013808
        /// Control register 3
        pub const CR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            EIE: u1,
            /// Ir mode enable
            IREN: u1,
            /// Ir low-power
            IRLP: u1,
            /// Half-duplex selection
            HDSEL: u1,
            /// Smartcard NACK enable
            NACK: u1,
            /// Smartcard mode enable
            SCEN: u1,
            /// DMA enable receiver
            DMAR: u1,
            /// DMA enable transmitter
            DMAT: u1,
            /// RTS enable
            RTSE: u1,
            /// CTS enable
            CTSE: u1,
            /// CTS interrupt enable
            CTSIE: u1,
            /// One sample bit method
            /// enable
            ONEBIT: u1,
            /// Overrun Disable
            OVRDIS: u1,
            /// DMA Disable on Reception
            /// Error
            DDRE: u1,
            /// Driver enable mode
            DEM: u1,
            /// Driver enable polarity
            /// selection
            DEP: u1,
            reserved0: u1,
            /// Smartcard auto-retry count
            SCARCNT: u3,
            /// Wakeup from Stop mode interrupt flag
            /// selection
            WUS: u2,
            /// Wakeup from Stop mode interrupt
            /// enable
            WUFIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x8);

        /// address: 0x4001380c
        /// Baud rate register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DIV_Fraction
            DIV_Fraction: u4,
            /// DIV_Mantissa
            DIV_Mantissa: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40013810
        /// Guard time and prescaler
        /// register
        pub const GTPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescaler value
            PSC: u8,
            /// Guard time value
            GT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40013814
        /// Receiver timeout register
        pub const RTOR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver timeout value
            RTO: u24,
            /// Block Length
            BLEN: u8,
        }), base_address + 0x14);

        /// address: 0x40013818
        /// Request register
        pub const RQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Auto baud rate request
            ABRRQ: u1,
            /// Send break request
            SBKRQ: u1,
            /// Mute mode request
            MMRQ: u1,
            /// Receive data flush request
            RXFRQ: u1,
            /// Transmit data flush
            /// request
            TXFRQ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x18);

        /// address: 0x4001381c
        /// Interrupt & status
        /// register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PE
            PE: u1,
            /// FE
            FE: u1,
            /// NF
            NF: u1,
            /// ORE
            ORE: u1,
            /// IDLE
            IDLE: u1,
            /// RXNE
            RXNE: u1,
            /// TC
            TC: u1,
            /// TXE
            TXE: u1,
            /// LBDF
            LBDF: u1,
            /// CTSIF
            CTSIF: u1,
            /// CTS
            CTS: u1,
            /// RTOF
            RTOF: u1,
            /// EOBF
            EOBF: u1,
            reserved0: u1,
            /// ABRE
            ABRE: u1,
            /// ABRF
            ABRF: u1,
            /// BUSY
            BUSY: u1,
            /// CMF
            CMF: u1,
            /// SBKF
            SBKF: u1,
            /// RWU
            RWU: u1,
            /// WUF
            WUF: u1,
            /// TEACK
            TEACK: u1,
            /// REACK
            REACK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x1c);

        /// address: 0x40013820
        /// Interrupt flag clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error clear flag
            PECF: u1,
            /// Framing error clear flag
            FECF: u1,
            /// Noise detected clear flag
            NCF: u1,
            /// Overrun error clear flag
            ORECF: u1,
            /// Idle line detected clear
            /// flag
            IDLECF: u1,
            reserved0: u1,
            /// Transmission complete clear
            /// flag
            TCCF: u1,
            reserved1: u1,
            /// LIN break detection clear
            /// flag
            LBDCF: u1,
            /// CTS clear flag
            CTSCF: u1,
            reserved2: u1,
            /// Receiver timeout clear
            /// flag
            RTOCF: u1,
            /// End of block clear flag
            EOBCF: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Character match clear flag
            CMCF: u1,
            reserved7: u1,
            reserved8: u1,
            /// Wakeup from Stop mode clear
            /// flag
            WUCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x20);

        /// address: 0x40013824
        /// Receive data register
        pub const RDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x24);

        /// address: 0x40013828
        /// Transmit data register
        pub const TDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x28);
    };
    pub const USART2 = struct {
        pub const base_address = 0x40004400;

        /// address: 0x40004400
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// USART enable
            UE: u1,
            /// USART enable in Stop mode
            UESM: u1,
            /// Receiver enable
            RE: u1,
            /// Transmitter enable
            TE: u1,
            /// IDLE interrupt enable
            IDLEIE: u1,
            /// RXNE interrupt enable
            RXNEIE: u1,
            /// Transmission complete interrupt
            /// enable
            TCIE: u1,
            /// interrupt enable
            TXEIE: u1,
            /// PE interrupt enable
            PEIE: u1,
            /// Parity selection
            PS: u1,
            /// Parity control enable
            PCE: u1,
            /// Receiver wakeup method
            WAKE: u1,
            /// Word length
            M0: u1,
            /// Mute mode enable
            MME: u1,
            /// Character match interrupt
            /// enable
            CMIE: u1,
            /// Oversampling mode
            OVER8: u1,
            /// DEDT0
            DEDT0: u1,
            /// DEDT1
            DEDT1: u1,
            /// DEDT2
            DEDT2: u1,
            /// DEDT3
            DEDT3: u1,
            /// Driver Enable de-assertion
            /// time
            DEDT4: u1,
            /// DEAT0
            DEAT0: u1,
            /// DEAT1
            DEAT1: u1,
            /// DEAT2
            DEAT2: u1,
            /// DEAT3
            DEAT3: u1,
            /// Driver Enable assertion
            /// time
            DEAT4: u1,
            /// Receiver timeout interrupt
            /// enable
            RTOIE: u1,
            /// End of Block interrupt
            /// enable
            EOBIE: u1,
            /// Word length
            M1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x0);

        /// address: 0x40004404
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// 7-bit Address Detection/4-bit Address
            /// Detection
            ADDM7: u1,
            /// LIN break detection length
            LBDL: u1,
            /// LIN break detection interrupt
            /// enable
            LBDIE: u1,
            reserved4: u1,
            /// Last bit clock pulse
            LBCL: u1,
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Clock enable
            CLKEN: u1,
            /// STOP bits
            STOP: u2,
            /// LIN mode enable
            LINEN: u1,
            /// Swap TX/RX pins
            SWAP: u1,
            /// RX pin active level
            /// inversion
            RXINV: u1,
            /// TX pin active level
            /// inversion
            TXINV: u1,
            /// Binary data inversion
            TAINV: u1,
            /// Most significant bit first
            MSBFIRST: u1,
            /// Auto baud rate enable
            ABREN: u1,
            /// ABRMOD0
            ABRMOD0: u1,
            /// Auto baud rate mode
            ABRMOD1: u1,
            /// Receiver timeout enable
            RTOEN: u1,
            /// Address of the USART node
            ADD0_3: u4,
            /// Address of the USART node
            ADD4_7: u4,
        }), base_address + 0x4);

        /// address: 0x40004408
        /// Control register 3
        pub const CR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            EIE: u1,
            /// Ir mode enable
            IREN: u1,
            /// Ir low-power
            IRLP: u1,
            /// Half-duplex selection
            HDSEL: u1,
            /// Smartcard NACK enable
            NACK: u1,
            /// Smartcard mode enable
            SCEN: u1,
            /// DMA enable receiver
            DMAR: u1,
            /// DMA enable transmitter
            DMAT: u1,
            /// RTS enable
            RTSE: u1,
            /// CTS enable
            CTSE: u1,
            /// CTS interrupt enable
            CTSIE: u1,
            /// One sample bit method
            /// enable
            ONEBIT: u1,
            /// Overrun Disable
            OVRDIS: u1,
            /// DMA Disable on Reception
            /// Error
            DDRE: u1,
            /// Driver enable mode
            DEM: u1,
            /// Driver enable polarity
            /// selection
            DEP: u1,
            reserved0: u1,
            /// Smartcard auto-retry count
            SCARCNT: u3,
            /// Wakeup from Stop mode interrupt flag
            /// selection
            WUS: u2,
            /// Wakeup from Stop mode interrupt
            /// enable
            WUFIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x8);

        /// address: 0x4000440c
        /// Baud rate register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DIV_Fraction
            DIV_Fraction: u4,
            /// DIV_Mantissa
            DIV_Mantissa: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40004410
        /// Guard time and prescaler
        /// register
        pub const GTPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescaler value
            PSC: u8,
            /// Guard time value
            GT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40004414
        /// Receiver timeout register
        pub const RTOR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver timeout value
            RTO: u24,
            /// Block Length
            BLEN: u8,
        }), base_address + 0x14);

        /// address: 0x40004418
        /// Request register
        pub const RQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Auto baud rate request
            ABRRQ: u1,
            /// Send break request
            SBKRQ: u1,
            /// Mute mode request
            MMRQ: u1,
            /// Receive data flush request
            RXFRQ: u1,
            /// Transmit data flush
            /// request
            TXFRQ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x18);

        /// address: 0x4000441c
        /// Interrupt & status
        /// register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PE
            PE: u1,
            /// FE
            FE: u1,
            /// NF
            NF: u1,
            /// ORE
            ORE: u1,
            /// IDLE
            IDLE: u1,
            /// RXNE
            RXNE: u1,
            /// TC
            TC: u1,
            /// TXE
            TXE: u1,
            /// LBDF
            LBDF: u1,
            /// CTSIF
            CTSIF: u1,
            /// CTS
            CTS: u1,
            /// RTOF
            RTOF: u1,
            /// EOBF
            EOBF: u1,
            reserved0: u1,
            /// ABRE
            ABRE: u1,
            /// ABRF
            ABRF: u1,
            /// BUSY
            BUSY: u1,
            /// CMF
            CMF: u1,
            /// SBKF
            SBKF: u1,
            /// RWU
            RWU: u1,
            /// WUF
            WUF: u1,
            /// TEACK
            TEACK: u1,
            /// REACK
            REACK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x1c);

        /// address: 0x40004420
        /// Interrupt flag clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error clear flag
            PECF: u1,
            /// Framing error clear flag
            FECF: u1,
            /// Noise detected clear flag
            NCF: u1,
            /// Overrun error clear flag
            ORECF: u1,
            /// Idle line detected clear
            /// flag
            IDLECF: u1,
            reserved0: u1,
            /// Transmission complete clear
            /// flag
            TCCF: u1,
            reserved1: u1,
            /// LIN break detection clear
            /// flag
            LBDCF: u1,
            /// CTS clear flag
            CTSCF: u1,
            reserved2: u1,
            /// Receiver timeout clear
            /// flag
            RTOCF: u1,
            /// End of block clear flag
            EOBCF: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Character match clear flag
            CMCF: u1,
            reserved7: u1,
            reserved8: u1,
            /// Wakeup from Stop mode clear
            /// flag
            WUCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x20);

        /// address: 0x40004424
        /// Receive data register
        pub const RDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x24);

        /// address: 0x40004428
        /// Transmit data register
        pub const TDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x28);
    };
    pub const USART4 = struct {
        pub const base_address = 0x40004c00;

        /// address: 0x40004c00
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// USART enable
            UE: u1,
            /// USART enable in Stop mode
            UESM: u1,
            /// Receiver enable
            RE: u1,
            /// Transmitter enable
            TE: u1,
            /// IDLE interrupt enable
            IDLEIE: u1,
            /// RXNE interrupt enable
            RXNEIE: u1,
            /// Transmission complete interrupt
            /// enable
            TCIE: u1,
            /// interrupt enable
            TXEIE: u1,
            /// PE interrupt enable
            PEIE: u1,
            /// Parity selection
            PS: u1,
            /// Parity control enable
            PCE: u1,
            /// Receiver wakeup method
            WAKE: u1,
            /// Word length
            M0: u1,
            /// Mute mode enable
            MME: u1,
            /// Character match interrupt
            /// enable
            CMIE: u1,
            /// Oversampling mode
            OVER8: u1,
            /// DEDT0
            DEDT0: u1,
            /// DEDT1
            DEDT1: u1,
            /// DEDT2
            DEDT2: u1,
            /// DEDT3
            DEDT3: u1,
            /// Driver Enable de-assertion
            /// time
            DEDT4: u1,
            /// DEAT0
            DEAT0: u1,
            /// DEAT1
            DEAT1: u1,
            /// DEAT2
            DEAT2: u1,
            /// DEAT3
            DEAT3: u1,
            /// Driver Enable assertion
            /// time
            DEAT4: u1,
            /// Receiver timeout interrupt
            /// enable
            RTOIE: u1,
            /// End of Block interrupt
            /// enable
            EOBIE: u1,
            /// Word length
            M1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x0);

        /// address: 0x40004c04
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// 7-bit Address Detection/4-bit Address
            /// Detection
            ADDM7: u1,
            /// LIN break detection length
            LBDL: u1,
            /// LIN break detection interrupt
            /// enable
            LBDIE: u1,
            reserved4: u1,
            /// Last bit clock pulse
            LBCL: u1,
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Clock enable
            CLKEN: u1,
            /// STOP bits
            STOP: u2,
            /// LIN mode enable
            LINEN: u1,
            /// Swap TX/RX pins
            SWAP: u1,
            /// RX pin active level
            /// inversion
            RXINV: u1,
            /// TX pin active level
            /// inversion
            TXINV: u1,
            /// Binary data inversion
            TAINV: u1,
            /// Most significant bit first
            MSBFIRST: u1,
            /// Auto baud rate enable
            ABREN: u1,
            /// ABRMOD0
            ABRMOD0: u1,
            /// Auto baud rate mode
            ABRMOD1: u1,
            /// Receiver timeout enable
            RTOEN: u1,
            /// Address of the USART node
            ADD0_3: u4,
            /// Address of the USART node
            ADD4_7: u4,
        }), base_address + 0x4);

        /// address: 0x40004c08
        /// Control register 3
        pub const CR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            EIE: u1,
            /// Ir mode enable
            IREN: u1,
            /// Ir low-power
            IRLP: u1,
            /// Half-duplex selection
            HDSEL: u1,
            /// Smartcard NACK enable
            NACK: u1,
            /// Smartcard mode enable
            SCEN: u1,
            /// DMA enable receiver
            DMAR: u1,
            /// DMA enable transmitter
            DMAT: u1,
            /// RTS enable
            RTSE: u1,
            /// CTS enable
            CTSE: u1,
            /// CTS interrupt enable
            CTSIE: u1,
            /// One sample bit method
            /// enable
            ONEBIT: u1,
            /// Overrun Disable
            OVRDIS: u1,
            /// DMA Disable on Reception
            /// Error
            DDRE: u1,
            /// Driver enable mode
            DEM: u1,
            /// Driver enable polarity
            /// selection
            DEP: u1,
            reserved0: u1,
            /// Smartcard auto-retry count
            SCARCNT: u3,
            /// Wakeup from Stop mode interrupt flag
            /// selection
            WUS: u2,
            /// Wakeup from Stop mode interrupt
            /// enable
            WUFIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x8);

        /// address: 0x40004c0c
        /// Baud rate register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DIV_Fraction
            DIV_Fraction: u4,
            /// DIV_Mantissa
            DIV_Mantissa: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40004c10
        /// Guard time and prescaler
        /// register
        pub const GTPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescaler value
            PSC: u8,
            /// Guard time value
            GT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40004c14
        /// Receiver timeout register
        pub const RTOR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver timeout value
            RTO: u24,
            /// Block Length
            BLEN: u8,
        }), base_address + 0x14);

        /// address: 0x40004c18
        /// Request register
        pub const RQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Auto baud rate request
            ABRRQ: u1,
            /// Send break request
            SBKRQ: u1,
            /// Mute mode request
            MMRQ: u1,
            /// Receive data flush request
            RXFRQ: u1,
            /// Transmit data flush
            /// request
            TXFRQ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x18);

        /// address: 0x40004c1c
        /// Interrupt & status
        /// register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PE
            PE: u1,
            /// FE
            FE: u1,
            /// NF
            NF: u1,
            /// ORE
            ORE: u1,
            /// IDLE
            IDLE: u1,
            /// RXNE
            RXNE: u1,
            /// TC
            TC: u1,
            /// TXE
            TXE: u1,
            /// LBDF
            LBDF: u1,
            /// CTSIF
            CTSIF: u1,
            /// CTS
            CTS: u1,
            /// RTOF
            RTOF: u1,
            /// EOBF
            EOBF: u1,
            reserved0: u1,
            /// ABRE
            ABRE: u1,
            /// ABRF
            ABRF: u1,
            /// BUSY
            BUSY: u1,
            /// CMF
            CMF: u1,
            /// SBKF
            SBKF: u1,
            /// RWU
            RWU: u1,
            /// WUF
            WUF: u1,
            /// TEACK
            TEACK: u1,
            /// REACK
            REACK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x1c);

        /// address: 0x40004c20
        /// Interrupt flag clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error clear flag
            PECF: u1,
            /// Framing error clear flag
            FECF: u1,
            /// Noise detected clear flag
            NCF: u1,
            /// Overrun error clear flag
            ORECF: u1,
            /// Idle line detected clear
            /// flag
            IDLECF: u1,
            reserved0: u1,
            /// Transmission complete clear
            /// flag
            TCCF: u1,
            reserved1: u1,
            /// LIN break detection clear
            /// flag
            LBDCF: u1,
            /// CTS clear flag
            CTSCF: u1,
            reserved2: u1,
            /// Receiver timeout clear
            /// flag
            RTOCF: u1,
            /// End of block clear flag
            EOBCF: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Character match clear flag
            CMCF: u1,
            reserved7: u1,
            reserved8: u1,
            /// Wakeup from Stop mode clear
            /// flag
            WUCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x20);

        /// address: 0x40004c24
        /// Receive data register
        pub const RDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x24);

        /// address: 0x40004c28
        /// Transmit data register
        pub const TDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x28);
    };
    pub const USART5 = struct {
        pub const base_address = 0x40005000;

        /// address: 0x40005000
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// USART enable
            UE: u1,
            /// USART enable in Stop mode
            UESM: u1,
            /// Receiver enable
            RE: u1,
            /// Transmitter enable
            TE: u1,
            /// IDLE interrupt enable
            IDLEIE: u1,
            /// RXNE interrupt enable
            RXNEIE: u1,
            /// Transmission complete interrupt
            /// enable
            TCIE: u1,
            /// interrupt enable
            TXEIE: u1,
            /// PE interrupt enable
            PEIE: u1,
            /// Parity selection
            PS: u1,
            /// Parity control enable
            PCE: u1,
            /// Receiver wakeup method
            WAKE: u1,
            /// Word length
            M0: u1,
            /// Mute mode enable
            MME: u1,
            /// Character match interrupt
            /// enable
            CMIE: u1,
            /// Oversampling mode
            OVER8: u1,
            /// DEDT0
            DEDT0: u1,
            /// DEDT1
            DEDT1: u1,
            /// DEDT2
            DEDT2: u1,
            /// DEDT3
            DEDT3: u1,
            /// Driver Enable de-assertion
            /// time
            DEDT4: u1,
            /// DEAT0
            DEAT0: u1,
            /// DEAT1
            DEAT1: u1,
            /// DEAT2
            DEAT2: u1,
            /// DEAT3
            DEAT3: u1,
            /// Driver Enable assertion
            /// time
            DEAT4: u1,
            /// Receiver timeout interrupt
            /// enable
            RTOIE: u1,
            /// End of Block interrupt
            /// enable
            EOBIE: u1,
            /// Word length
            M1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x0);

        /// address: 0x40005004
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// 7-bit Address Detection/4-bit Address
            /// Detection
            ADDM7: u1,
            /// LIN break detection length
            LBDL: u1,
            /// LIN break detection interrupt
            /// enable
            LBDIE: u1,
            reserved4: u1,
            /// Last bit clock pulse
            LBCL: u1,
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Clock enable
            CLKEN: u1,
            /// STOP bits
            STOP: u2,
            /// LIN mode enable
            LINEN: u1,
            /// Swap TX/RX pins
            SWAP: u1,
            /// RX pin active level
            /// inversion
            RXINV: u1,
            /// TX pin active level
            /// inversion
            TXINV: u1,
            /// Binary data inversion
            TAINV: u1,
            /// Most significant bit first
            MSBFIRST: u1,
            /// Auto baud rate enable
            ABREN: u1,
            /// ABRMOD0
            ABRMOD0: u1,
            /// Auto baud rate mode
            ABRMOD1: u1,
            /// Receiver timeout enable
            RTOEN: u1,
            /// Address of the USART node
            ADD0_3: u4,
            /// Address of the USART node
            ADD4_7: u4,
        }), base_address + 0x4);

        /// address: 0x40005008
        /// Control register 3
        pub const CR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            EIE: u1,
            /// Ir mode enable
            IREN: u1,
            /// Ir low-power
            IRLP: u1,
            /// Half-duplex selection
            HDSEL: u1,
            /// Smartcard NACK enable
            NACK: u1,
            /// Smartcard mode enable
            SCEN: u1,
            /// DMA enable receiver
            DMAR: u1,
            /// DMA enable transmitter
            DMAT: u1,
            /// RTS enable
            RTSE: u1,
            /// CTS enable
            CTSE: u1,
            /// CTS interrupt enable
            CTSIE: u1,
            /// One sample bit method
            /// enable
            ONEBIT: u1,
            /// Overrun Disable
            OVRDIS: u1,
            /// DMA Disable on Reception
            /// Error
            DDRE: u1,
            /// Driver enable mode
            DEM: u1,
            /// Driver enable polarity
            /// selection
            DEP: u1,
            reserved0: u1,
            /// Smartcard auto-retry count
            SCARCNT: u3,
            /// Wakeup from Stop mode interrupt flag
            /// selection
            WUS: u2,
            /// Wakeup from Stop mode interrupt
            /// enable
            WUFIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x8);

        /// address: 0x4000500c
        /// Baud rate register
        pub const BRR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DIV_Fraction
            DIV_Fraction: u4,
            /// DIV_Mantissa
            DIV_Mantissa: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40005010
        /// Guard time and prescaler
        /// register
        pub const GTPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Prescaler value
            PSC: u8,
            /// Guard time value
            GT: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40005014
        /// Receiver timeout register
        pub const RTOR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receiver timeout value
            RTO: u24,
            /// Block Length
            BLEN: u8,
        }), base_address + 0x14);

        /// address: 0x40005018
        /// Request register
        pub const RQR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Auto baud rate request
            ABRRQ: u1,
            /// Send break request
            SBKRQ: u1,
            /// Mute mode request
            MMRQ: u1,
            /// Receive data flush request
            RXFRQ: u1,
            /// Transmit data flush
            /// request
            TXFRQ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x18);

        /// address: 0x4000501c
        /// Interrupt & status
        /// register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PE
            PE: u1,
            /// FE
            FE: u1,
            /// NF
            NF: u1,
            /// ORE
            ORE: u1,
            /// IDLE
            IDLE: u1,
            /// RXNE
            RXNE: u1,
            /// TC
            TC: u1,
            /// TXE
            TXE: u1,
            /// LBDF
            LBDF: u1,
            /// CTSIF
            CTSIF: u1,
            /// CTS
            CTS: u1,
            /// RTOF
            RTOF: u1,
            /// EOBF
            EOBF: u1,
            reserved0: u1,
            /// ABRE
            ABRE: u1,
            /// ABRF
            ABRF: u1,
            /// BUSY
            BUSY: u1,
            /// CMF
            CMF: u1,
            /// SBKF
            SBKF: u1,
            /// RWU
            RWU: u1,
            /// WUF
            WUF: u1,
            /// TEACK
            TEACK: u1,
            /// REACK
            REACK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x1c);

        /// address: 0x40005020
        /// Interrupt flag clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error clear flag
            PECF: u1,
            /// Framing error clear flag
            FECF: u1,
            /// Noise detected clear flag
            NCF: u1,
            /// Overrun error clear flag
            ORECF: u1,
            /// Idle line detected clear
            /// flag
            IDLECF: u1,
            reserved0: u1,
            /// Transmission complete clear
            /// flag
            TCCF: u1,
            reserved1: u1,
            /// LIN break detection clear
            /// flag
            LBDCF: u1,
            /// CTS clear flag
            CTSCF: u1,
            reserved2: u1,
            /// Receiver timeout clear
            /// flag
            RTOCF: u1,
            /// End of block clear flag
            EOBCF: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Character match clear flag
            CMCF: u1,
            reserved7: u1,
            reserved8: u1,
            /// Wakeup from Stop mode clear
            /// flag
            WUCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x20);

        /// address: 0x40005024
        /// Receive data register
        pub const RDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x24);

        /// address: 0x40005028
        /// Transmit data register
        pub const TDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x28);
    };

    /// Independent watchdog
    pub const IWDG = struct {
        pub const base_address = 0x40003000;

        /// address: 0x40003000
        /// Key register
        pub const KR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Key value (write only, read
            /// 0x0000)
            KEY: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40003004
        /// Prescaler register
        pub const PR = @intToPtr(*volatile MmioInt(32, u3), base_address + 0x4);

        /// address: 0x40003008
        /// Reload register
        pub const RLR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Watchdog counter reload
            /// value
            RL: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x8);

        /// address: 0x4000300c
        /// Status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Watchdog prescaler value
            /// update
            PVU: u1,
            /// Watchdog counter reload value
            /// update
            RVU: u1,
            /// Watchdog counter window value
            /// update
            WVU: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0xc);

        /// address: 0x40003010
        /// Window register
        pub const WINR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Watchdog counter window
            /// value
            WIN: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x10);
    };

    /// System window watchdog
    pub const WWDG = struct {
        pub const base_address = 0x40002c00;

        /// address: 0x40002c00
        /// Control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 7-bit counter (MSB to LSB)
            T: u7,
            /// Activation bit
            WDGA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x40002c04
        /// Configuration register
        pub const CFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 7-bit window value
            W: u7,
            /// WDGTB0
            WDGTB0: u1,
            /// Timer base
            WDGTB1: u1,
            /// Early wakeup interrupt
            EWI: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x4);

        /// address: 0x40002c08
        /// Status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Early wakeup interrupt
            /// flag
            EWIF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x8);
    };

    /// Firewall
    pub const Firewall = struct {
        pub const base_address = 0x40011c00;

        /// address: 0x40011c00
        /// Code segment start address
        pub const FIREWALL_CSSA = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// code segment start address
            ADD: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x0);

        /// address: 0x40011c04
        /// Code segment length
        pub const FIREWALL_CSL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// code segment length
            LENG: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0x4);

        /// address: 0x40011c08
        /// Non-volatile data segment start
        /// address
        pub const FIREWALL_NVDSSA = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Non-volatile data segment start
            /// address
            ADD: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x8);

        /// address: 0x40011c0c
        /// Non-volatile data segment
        /// length
        pub const FIREWALL_NVDSL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Non-volatile data segment
            /// length
            LENG: u14,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
        }), base_address + 0xc);

        /// address: 0x40011c10
        /// Volatile data segment start
        /// address
        pub const FIREWALL_VDSSA = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Volatile data segment start
            /// address
            ADD: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40011c14
        /// Volatile data segment length
        pub const FIREWALL_VDSL = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Non-volatile data segment
            /// length
            LENG: u10,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40011c20
        /// Configuration register
        pub const FIREWALL_CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Firewall pre alarm
            FPA: u1,
            /// Volatile data shared
            VDS: u1,
            /// Volatile data execution
            VDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x20);
    };

    /// Reset and clock control
    pub const RCC = struct {
        pub const base_address = 0x40021000;

        /// address: 0x40021000
        /// Clock control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 16 MHz high-speed internal clock
            /// enable
            HSI16ON: u1,
            /// High-speed internal clock enable bit for
            /// some IP kernels
            HSI16KERON: u1,
            /// Internal high-speed clock ready
            /// flag
            HSI16RDYF: u1,
            /// HSI16DIVEN
            HSI16DIVEN: u1,
            /// HSI16DIVF
            HSI16DIVF: u1,
            /// 16 MHz high-speed internal clock output
            /// enable
            HSI16OUTEN: u1,
            reserved0: u1,
            reserved1: u1,
            /// MSI clock enable bit
            MSION: u1,
            /// MSI clock ready flag
            MSIRDY: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// HSE clock enable bit
            HSEON: u1,
            /// HSE clock ready flag
            HSERDY: u1,
            /// HSE clock bypass bit
            HSEBYP: u1,
            /// Clock security system on HSE enable
            /// bit
            CSSLSEON: u1,
            /// TC/LCD prescaler
            RTCPRE: u2,
            reserved8: u1,
            reserved9: u1,
            /// PLL enable bit
            PLLON: u1,
            /// PLL clock ready flag
            PLLRDY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x0);

        /// address: 0x40021004
        /// Internal clock sources calibration
        /// register
        pub const ICSCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// nternal high speed clock
            /// calibration
            HSI16CAL: u8,
            /// High speed internal clock
            /// trimming
            HSI16TRIM: u5,
            /// MSI clock ranges
            MSIRANGE: u3,
            /// MSI clock calibration
            MSICAL: u8,
            /// MSI clock trimming
            MSITRIM: u8,
        }), base_address + 0x4);

        /// address: 0x4002100c
        /// Clock configuration register
        pub const CFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// System clock switch
            SW: u2,
            /// System clock switch status
            SWS: u2,
            /// AHB prescaler
            HPRE: u4,
            /// APB low-speed prescaler
            /// (APB1)
            PPRE1: u3,
            /// APB high-speed prescaler
            /// (APB2)
            PPRE2: u3,
            reserved0: u1,
            /// Wake-up from stop clock
            /// selection
            STOPWUCK: u1,
            /// PLL entry clock source
            PLLSRC: u1,
            reserved1: u1,
            /// PLL multiplication factor
            PLLMUL: u4,
            /// PLL output division
            PLLDIV: u2,
            /// Microcontroller clock output
            /// selection
            MCOSEL: u3,
            reserved2: u1,
            /// Microcontroller clock output
            /// prescaler
            MCOPRE: u3,
            padding0: u1,
        }), base_address + 0xc);

        /// address: 0x40021010
        /// Clock interrupt enable
        /// register
        pub const CIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// LSI ready interrupt flag
            LSIRDYIE: u1,
            /// LSE ready interrupt flag
            LSERDYIE: u1,
            /// HSI16 ready interrupt flag
            HSI16RDYIE: u1,
            /// HSE ready interrupt flag
            HSERDYIE: u1,
            /// PLL ready interrupt flag
            PLLRDYIE: u1,
            /// MSI ready interrupt flag
            MSIRDYIE: u1,
            reserved0: u1,
            /// LSE CSS interrupt flag
            CSSLSE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x10);

        /// address: 0x40021014
        /// Clock interrupt flag register
        pub const CIFR = @intToPtr(*volatile Mmio(32, packed struct {
            /// LSI ready interrupt flag
            LSIRDYF: u1,
            /// LSE ready interrupt flag
            LSERDYF: u1,
            /// HSI16 ready interrupt flag
            HSI16RDYF: u1,
            /// HSE ready interrupt flag
            HSERDYF: u1,
            /// PLL ready interrupt flag
            PLLRDYF: u1,
            /// MSI ready interrupt flag
            MSIRDYF: u1,
            reserved0: u1,
            /// LSE Clock Security System Interrupt
            /// flag
            CSSLSEF: u1,
            /// Clock Security System Interrupt
            /// flag
            CSSHSEF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x14);

        /// address: 0x40021018
        /// Clock interrupt clear register
        pub const CICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// LSI ready Interrupt clear
            LSIRDYC: u1,
            /// LSE ready Interrupt clear
            LSERDYC: u1,
            /// HSI16 ready Interrupt
            /// clear
            HSI16RDYC: u1,
            /// HSE ready Interrupt clear
            HSERDYC: u1,
            /// PLL ready Interrupt clear
            PLLRDYC: u1,
            /// MSI ready Interrupt clear
            MSIRDYC: u1,
            reserved0: u1,
            /// LSE Clock Security System Interrupt
            /// clear
            CSSLSEC: u1,
            /// Clock Security System Interrupt
            /// clear
            CSSHSEC: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x18);

        /// address: 0x4002101c
        /// GPIO reset register
        pub const IOPRSTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// I/O port A reset
            IOPARST: u1,
            /// I/O port B reset
            IOPBRST: u1,
            /// I/O port A reset
            IOPCRST: u1,
            /// I/O port D reset
            IOPDRST: u1,
            /// I/O port E reset
            IOPERST: u1,
            reserved0: u1,
            reserved1: u1,
            /// I/O port H reset
            IOPHRST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x1c);

        /// address: 0x40021020
        /// AHB peripheral reset register
        pub const AHBRSTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA reset
            DMARST: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Memory interface reset
            MIFRST: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// Test integration module
            /// reset
            CRCRST: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// Crypto module reset
            CRYPRST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x20);

        /// address: 0x40021024
        /// APB2 peripheral reset register
        pub const APB2RSTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// System configuration controller
            /// reset
            SYSCFGRST: u1,
            reserved0: u1,
            /// TIM21 timer reset
            TIM21RST: u1,
            reserved1: u1,
            reserved2: u1,
            /// TIM22 timer reset
            TIM22RST: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// ADC interface reset
            ADCRST: u1,
            reserved6: u1,
            reserved7: u1,
            /// SPI 1 reset
            SPI1RST: u1,
            reserved8: u1,
            /// USART1 reset
            USART1RST: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// DBG reset
            DBGRST: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x24);

        /// address: 0x40021028
        /// APB1 peripheral reset register
        pub const APB1RSTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timer 2 reset
            TIM2RST: u1,
            /// Timer 3 reset
            TIM3RST: u1,
            reserved0: u1,
            reserved1: u1,
            /// Timer 6 reset
            TIM6RST: u1,
            /// Timer 7 reset
            TIM7RST: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Window watchdog reset
            WWDGRST: u1,
            reserved7: u1,
            reserved8: u1,
            /// SPI2 reset
            SPI2RST: u1,
            reserved9: u1,
            reserved10: u1,
            /// USART2 reset
            USART2RST: u1,
            /// LPUART1 reset
            LPUART1RST: u1,
            /// USART4 reset
            USART4RST: u1,
            /// USART5 reset
            USART5RST: u1,
            /// I2C1 reset
            I2C1RST: u1,
            /// I2C2 reset
            I2C2RST: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// CRC reset
            CRCRST: u1,
            /// Power interface reset
            PWRRST: u1,
            reserved15: u1,
            /// I2C3 reset
            I2C3: u1,
            /// Low power timer reset
            LPTIM1RST: u1,
        }), base_address + 0x28);

        /// address: 0x4002102c
        /// GPIO clock enable register
        pub const IOPENR = @intToPtr(*volatile Mmio(32, packed struct {
            /// IO port A clock enable bit
            IOPAEN: u1,
            /// IO port B clock enable bit
            IOPBEN: u1,
            /// IO port A clock enable bit
            IOPCEN: u1,
            /// I/O port D clock enable
            /// bit
            IOPDEN: u1,
            /// IO port E clock enable bit
            IOPEEN: u1,
            reserved0: u1,
            reserved1: u1,
            /// I/O port H clock enable
            /// bit
            IOPHEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x2c);

        /// address: 0x40021030
        /// AHB peripheral clock enable
        /// register
        pub const AHBENR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA clock enable bit
            DMAEN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// NVM interface clock enable
            /// bit
            MIFEN: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// CRC clock enable bit
            CRCEN: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// Crypto clock enable bit
            CRYPEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x30);

        /// address: 0x40021034
        /// APB2 peripheral clock enable
        /// register
        pub const APB2ENR = @intToPtr(*volatile Mmio(32, packed struct {
            /// System configuration controller clock
            /// enable bit
            SYSCFGEN: u1,
            reserved0: u1,
            /// TIM21 timer clock enable
            /// bit
            TIM21EN: u1,
            reserved1: u1,
            reserved2: u1,
            /// TIM22 timer clock enable
            /// bit
            TIM22EN: u1,
            reserved3: u1,
            /// Firewall clock enable bit
            FWEN: u1,
            reserved4: u1,
            /// ADC clock enable bit
            ADCEN: u1,
            reserved5: u1,
            reserved6: u1,
            /// SPI1 clock enable bit
            SPI1EN: u1,
            reserved7: u1,
            /// USART1 clock enable bit
            USART1EN: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// DBG clock enable bit
            DBGEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x34);

        /// address: 0x40021038
        /// APB1 peripheral clock enable
        /// register
        pub const APB1ENR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timer2 clock enable bit
            TIM2EN: u1,
            reserved0: u1,
            /// Timer 3 clock enbale bit
            TIM3EN: u1,
            reserved1: u1,
            /// Timer 6 clock enable bit
            TIM6EN: u1,
            /// Timer 7 clock enable bit
            TIM7EN: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Window watchdog clock enable
            /// bit
            WWDGEN: u1,
            reserved7: u1,
            reserved8: u1,
            /// SPI2 clock enable bit
            SPI2EN: u1,
            reserved9: u1,
            reserved10: u1,
            /// UART2 clock enable bit
            USART2EN: u1,
            /// LPUART1 clock enable bit
            LPUART1EN: u1,
            /// USART4 clock enable bit
            USART4EN: u1,
            /// USART5 clock enable bit
            USART5EN: u1,
            /// I2C1 clock enable bit
            I2C1EN: u1,
            /// I2C2 clock enable bit
            I2C2EN: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Power interface clock enable
            /// bit
            PWREN: u1,
            reserved16: u1,
            /// I2C3 clock enable bit
            I2C3EN: u1,
            /// Low power timer clock enable
            /// bit
            LPTIM1EN: u1,
        }), base_address + 0x38);

        /// address: 0x4002103c
        /// GPIO clock enable in sleep mode
        /// register
        pub const IOPSMEN = @intToPtr(*volatile Mmio(32, packed struct {
            /// Port A clock enable during Sleep mode
            /// bit
            IOPASMEN: u1,
            /// Port B clock enable during Sleep mode
            /// bit
            IOPBSMEN: u1,
            /// Port C clock enable during Sleep mode
            /// bit
            IOPCSMEN: u1,
            /// Port D clock enable during Sleep mode
            /// bit
            IOPDSMEN: u1,
            /// Port E clock enable during Sleep mode
            /// bit
            IOPESMEN: u1,
            reserved0: u1,
            reserved1: u1,
            /// Port H clock enable during Sleep mode
            /// bit
            IOPHSMEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x3c);

        /// address: 0x40021040
        /// AHB peripheral clock enable in sleep mode
        /// register
        pub const AHBSMENR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA clock enable during sleep mode
            /// bit
            DMASMEN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// NVM interface clock enable during sleep
            /// mode bit
            MIFSMEN: u1,
            /// SRAM interface clock enable during sleep
            /// mode bit
            SRAMSMEN: u1,
            reserved7: u1,
            reserved8: u1,
            /// CRC clock enable during sleep mode
            /// bit
            CRCSMEN: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            /// Crypto clock enable during sleep mode
            /// bit
            CRYPTSMEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
        }), base_address + 0x40);

        /// address: 0x40021044
        /// APB2 peripheral clock enable in sleep mode
        /// register
        pub const APB2SMENR = @intToPtr(*volatile Mmio(32, packed struct {
            /// System configuration controller clock
            /// enable during sleep mode bit
            SYSCFGSMEN: u1,
            reserved0: u1,
            /// TIM21 timer clock enable during sleep
            /// mode bit
            TIM21SMEN: u1,
            reserved1: u1,
            reserved2: u1,
            /// TIM22 timer clock enable during sleep
            /// mode bit
            TIM22SMEN: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// ADC clock enable during sleep mode
            /// bit
            ADCSMEN: u1,
            reserved6: u1,
            reserved7: u1,
            /// SPI1 clock enable during sleep mode
            /// bit
            SPI1SMEN: u1,
            reserved8: u1,
            /// USART1 clock enable during sleep mode
            /// bit
            USART1SMEN: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// DBG clock enable during sleep mode
            /// bit
            DBGSMEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x44);

        /// address: 0x40021048
        /// APB1 peripheral clock enable in sleep mode
        /// register
        pub const APB1SMENR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timer2 clock enable during sleep mode
            /// bit
            TIM2SMEN: u1,
            /// Timer 3 clock enable during sleep mode
            /// bit
            TIM3SMEN: u1,
            reserved0: u1,
            reserved1: u1,
            /// Timer 6 clock enable during sleep mode
            /// bit
            TIM6SMEN: u1,
            /// Timer 7 clock enable during sleep mode
            /// bit
            TIM7SMEN: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Window watchdog clock enable during
            /// sleep mode bit
            WWDGSMEN: u1,
            reserved7: u1,
            reserved8: u1,
            /// SPI2 clock enable during sleep mode
            /// bit
            SPI2SMEN: u1,
            reserved9: u1,
            reserved10: u1,
            /// UART2 clock enable during sleep mode
            /// bit
            USART2SMEN: u1,
            /// LPUART1 clock enable during sleep mode
            /// bit
            LPUART1SMEN: u1,
            /// USART4 clock enabe during sleep mode
            /// bit
            USART4SMEN: u1,
            /// USART5 clock enable during sleep mode
            /// bit
            USART5SMEN: u1,
            /// I2C1 clock enable during sleep mode
            /// bit
            I2C1SMEN: u1,
            /// I2C2 clock enable during sleep mode
            /// bit
            I2C2SMEN: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// Clock recovery system clock enable
            /// during sleep mode bit
            CRSSMEN: u1,
            /// Power interface clock enable during
            /// sleep mode bit
            PWRSMEN: u1,
            reserved15: u1,
            /// I2C3 clock enable during sleep mode
            /// bit
            I2C3SMEN: u1,
            /// Low power timer clock enable during
            /// sleep mode bit
            LPTIM1SMEN: u1,
        }), base_address + 0x48);

        /// address: 0x4002104c
        /// Clock configuration register
        pub const CCIPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// USART1SEL0
            USART1SEL0: u1,
            /// USART1 clock source selection
            /// bits
            USART1SEL1: u1,
            /// USART2SEL0
            USART2SEL0: u1,
            /// USART2 clock source selection
            /// bits
            USART2SEL1: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// LPUART1SEL0
            LPUART1SEL0: u1,
            /// LPUART1 clock source selection
            /// bits
            LPUART1SEL1: u1,
            /// I2C1SEL0
            I2C1SEL0: u1,
            /// I2C1 clock source selection
            /// bits
            I2C1SEL1: u1,
            reserved6: u1,
            reserved7: u1,
            /// I2C3 clock source selection
            /// bits
            I2C3SEL0: u1,
            /// I2C3 clock source selection
            /// bits
            I2C3SEL1: u1,
            /// LPTIM1SEL0
            LPTIM1SEL0: u1,
            /// Low Power Timer clock source selection
            /// bits
            LPTIM1SEL1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x4c);

        /// address: 0x40021050
        /// Control and status register
        pub const CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Internal low-speed oscillator
            /// enable
            LSION: u1,
            /// Internal low-speed oscillator ready
            /// bit
            LSIRDY: u1,
            /// LSI clock input to IWDG in
            /// Ultra-low-power mode (Stop and Standby) enable
            /// bit
            LSIIWDGLP: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// External low-speed oscillator enable
            /// bit
            LSEON: u1,
            /// External low-speed oscillator ready
            /// bit
            LSERDY: u1,
            /// External low-speed oscillator bypass
            /// bit
            LSEBYP: u1,
            /// LSEDRV
            LSEDRV: u2,
            /// CSSLSEON
            CSSLSEON: u1,
            /// CSS on LSE failure detection
            /// flag
            CSSLSED: u1,
            reserved5: u1,
            /// RTC and LCD clock source selection
            /// bits
            RTCSEL: u2,
            /// RTC clock enable bit
            RTCEN: u1,
            /// RTC software reset bit
            RTCRST: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Remove reset flag
            RMVF: u1,
            /// Firewall reset flag
            FWRSTF: u1,
            /// OBLRSTF
            OBLRSTF: u1,
            /// PIN reset flag
            PINRSTF: u1,
            /// POR/PDR reset flag
            PORRSTF: u1,
            /// Software reset flag
            SFTRSTF: u1,
            /// Independent watchdog reset
            /// flag
            IWDGRSTF: u1,
            /// Window watchdog reset flag
            WWDGRSTF: u1,
            /// Low-power reset flag
            LPWRSTF: u1,
        }), base_address + 0x50);
    };

    /// System configuration controller and COMP
    /// register
    pub const SYSCFG_COMP = struct {
        pub const base_address = 0x40010000;

        /// address: 0x40010000
        /// SYSCFG configuration register
        /// 1
        pub const CFGR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Memory mapping selection
            /// bits
            MEM_MODE: u2,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Boot mode selected by the boot pins
            /// status bits
            BOOT_MODE: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40010004
        /// SYSCFG configuration register
        /// 2
        pub const CFGR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Firewall disable bit
            FWDISEN: u1,
            /// Configuration of internal VLCD rail
            /// connection to optional external
            /// capacitor
            CAPA: u3,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Fm+ drive capability on PB6 enable
            /// bit
            I2C_PB6_FMP: u1,
            /// Fm+ drive capability on PB7 enable
            /// bit
            I2C_PB7_FMP: u1,
            /// Fm+ drive capability on PB8 enable
            /// bit
            I2C_PB8_FMP: u1,
            /// Fm+ drive capability on PB9 enable
            /// bit
            I2C_PB9_FMP: u1,
            /// I2C1 Fm+ drive capability enable
            /// bit
            I2C1_FMP: u1,
            /// I2C2 Fm+ drive capability enable
            /// bit
            I2C2_FMP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x4);

        /// address: 0x40010008
        /// external interrupt configuration register
        /// 1
        pub const EXTICR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// EXTI x configuration (x = 0 to
            /// 3)
            EXTI0: u4,
            /// EXTI x configuration (x = 0 to
            /// 3)
            EXTI1: u4,
            /// EXTI x configuration (x = 0 to
            /// 3)
            EXTI2: u4,
            /// EXTI x configuration (x = 0 to
            /// 3)
            EXTI3: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4001000c
        /// external interrupt configuration register
        /// 2
        pub const EXTICR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// EXTI x configuration (x = 4 to
            /// 7)
            EXTI4: u4,
            /// EXTI x configuration (x = 4 to
            /// 7)
            EXTI5: u4,
            /// EXTI x configuration (x = 4 to
            /// 7)
            EXTI6: u4,
            /// EXTI x configuration (x = 4 to
            /// 7)
            EXTI7: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40010010
        /// external interrupt configuration register
        /// 3
        pub const EXTICR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// EXTI x configuration (x = 8 to
            /// 11)
            EXTI8: u4,
            /// EXTI x configuration (x = 8 to
            /// 11)
            EXTI9: u4,
            /// EXTI10
            EXTI10: u4,
            /// EXTI x configuration (x = 8 to
            /// 11)
            EXTI11: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40010014
        /// external interrupt configuration register
        /// 4
        pub const EXTICR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// EXTI12
            EXTI12: u4,
            /// EXTI13
            EXTI13: u4,
            /// EXTI14
            EXTI14: u4,
            /// EXTI x configuration (x = 12 to
            /// 15)
            EXTI15: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40010020
        /// SYSCFG configuration register
        /// 3
        pub const CFGR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Vref Enable bit
            EN_BGAP: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// BGAP_ADC connection bit
            SEL_VREF_OUT: u2,
            reserved3: u1,
            reserved4: u1,
            /// VREFINT reference for ADC enable
            /// bit
            ENBUF_BGAP_ADC: u1,
            /// Sensor reference for ADC enable
            /// bit
            ENBUF_SENSOR_ADC: u1,
            reserved5: u1,
            reserved6: u1,
            /// VREFINT reference for comparator 2
            /// enable bit
            ENBUF_VREFINT_COMP: u1,
            /// VREFINT reference for 48 MHz RC
            /// oscillator enable bit
            ENREF_RC48MHz: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            /// VREFINT for 48 MHz RC oscillator ready
            /// flag
            REF_RC48MHz_RDYF: u1,
            /// Sensor for ADC ready flag
            SENSOR_ADC_RDYF: u1,
            /// VREFINT for ADC ready flag
            VREFINT_ADC_RDYF: u1,
            /// VREFINT for comparator ready
            /// flag
            VREFINT_COMP_RDYF: u1,
            /// VREFINT ready flag
            VREFINT_RDYF: u1,
            /// REF_CTRL lock bit
            REF_LOCK: u1,
        }), base_address + 0x20);

        /// address: 0x40010018
        /// Comparator 1 control and status
        /// register
        pub const COMP1_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Comparator 1 enable bit
            COMP1EN: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Comparator 1 Input Minus connection
            /// configuration bit
            COMP1INNSEL: u2,
            reserved3: u1,
            reserved4: u1,
            /// Comparator 1 window mode selection
            /// bit
            COMP1WM: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Comparator 1 LPTIM input propagation
            /// bit
            COMP1LPTIMIN1: u1,
            reserved8: u1,
            reserved9: u1,
            /// Comparator 1 polarity selection
            /// bit
            COMP1POLARITY: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            /// Comparator 1 output status
            /// bit
            COMP1VALUE: u1,
            /// COMP1_CSR register lock
            /// bit
            COMP1LOCK: u1,
        }), base_address + 0x18);

        /// address: 0x4001001c
        /// Comparator 2 control and status
        /// register
        pub const COMP2_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Comparator 2 enable bit
            COMP2EN: u1,
            reserved0: u1,
            reserved1: u1,
            /// Comparator 2 power mode selection
            /// bit
            COMP2SPEED: u1,
            /// Comparator 2 Input Minus connection
            /// configuration bit
            COMP2INNSEL: u3,
            reserved2: u1,
            /// Comparator 2 Input Plus connection
            /// configuration bit
            COMP2INPSEL: u3,
            reserved3: u1,
            /// Comparator 2 LPTIM input 2 propagation
            /// bit
            COMP2LPTIMIN2: u1,
            /// Comparator 2 LPTIM input 1 propagation
            /// bit
            COMP2LPTIMIN1: u1,
            reserved4: u1,
            /// Comparator 2 polarity selection
            /// bit
            COMP2POLARITY: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            /// Comparator 2 output status
            /// bit
            COMP2VALUE: u1,
            /// COMP2_CSR register lock
            /// bit
            COMP2LOCK: u1,
        }), base_address + 0x1c);
    };

    /// Serial peripheral interface
    pub const SPI1 = struct {
        pub const base_address = 0x40013000;

        /// address: 0x40013000
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Master selection
            MSTR: u1,
            /// Baud rate control
            BR: u3,
            /// SPI enable
            SPE: u1,
            /// Frame format
            LSBFIRST: u1,
            /// Internal slave select
            SSI: u1,
            /// Software slave management
            SSM: u1,
            /// Receive only
            RXONLY: u1,
            /// Data frame format
            DFF: u1,
            /// CRC transfer next
            CRCNEXT: u1,
            /// Hardware CRC calculation
            /// enable
            CRCEN: u1,
            /// Output enable in bidirectional
            /// mode
            BIDIOE: u1,
            /// Bidirectional data mode
            /// enable
            BIDIMODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40013004
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx buffer DMA enable
            RXDMAEN: u1,
            /// Tx buffer DMA enable
            TXDMAEN: u1,
            /// SS output enable
            SSOE: u1,
            reserved0: u1,
            /// Frame format
            FRF: u1,
            /// Error interrupt enable
            ERRIE: u1,
            /// RX buffer not empty interrupt
            /// enable
            RXNEIE: u1,
            /// Tx buffer empty interrupt
            /// enable
            TXEIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x40013008
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive buffer not empty
            RXNE: u1,
            /// Transmit buffer empty
            TXE: u1,
            /// Channel side
            CHSIDE: u1,
            /// Underrun flag
            UDR: u1,
            /// CRC error flag
            CRCERR: u1,
            /// Mode fault
            MODF: u1,
            /// Overrun flag
            OVR: u1,
            /// Busy flag
            BSY: u1,
            /// TI frame format error
            TIFRFE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x8);

        /// address: 0x4001300c
        /// data register
        pub const DR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xc);

        /// address: 0x40013010
        /// CRC polynomial register
        pub const CRCPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// CRC polynomial register
            CRCPOLY: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40013014
        /// RX CRC register
        pub const RXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx CRC register
            RxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40013018
        /// TX CRC register
        pub const TXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tx CRC register
            TxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4001301c
        /// I2S configuration register
        pub const I2SCFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel length (number of bits per audio
            /// channel)
            CHLEN: u1,
            /// Data length to be
            /// transferred
            DATLEN: u2,
            /// Steady state clock
            /// polarity
            CKPOL: u1,
            /// I2S standard selection
            I2SSTD: u2,
            reserved0: u1,
            /// PCM frame synchronization
            PCMSYNC: u1,
            /// I2S configuration mode
            I2SCFG: u2,
            /// I2S Enable
            I2SE: u1,
            /// I2S mode selection
            I2SMOD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x1c);

        /// address: 0x40013020
        /// I2S prescaler register
        pub const I2SPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// I2S Linear prescaler
            I2SDIV: u8,
            /// Odd factor for the
            /// prescaler
            ODD: u1,
            /// Master clock output enable
            MCKOE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x20);
    };
    pub const SPI2 = struct {
        pub const base_address = 0x40003800;

        /// address: 0x40003800
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Clock phase
            CPHA: u1,
            /// Clock polarity
            CPOL: u1,
            /// Master selection
            MSTR: u1,
            /// Baud rate control
            BR: u3,
            /// SPI enable
            SPE: u1,
            /// Frame format
            LSBFIRST: u1,
            /// Internal slave select
            SSI: u1,
            /// Software slave management
            SSM: u1,
            /// Receive only
            RXONLY: u1,
            /// Data frame format
            DFF: u1,
            /// CRC transfer next
            CRCNEXT: u1,
            /// Hardware CRC calculation
            /// enable
            CRCEN: u1,
            /// Output enable in bidirectional
            /// mode
            BIDIOE: u1,
            /// Bidirectional data mode
            /// enable
            BIDIMODE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x0);

        /// address: 0x40003804
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx buffer DMA enable
            RXDMAEN: u1,
            /// Tx buffer DMA enable
            TXDMAEN: u1,
            /// SS output enable
            SSOE: u1,
            reserved0: u1,
            /// Frame format
            FRF: u1,
            /// Error interrupt enable
            ERRIE: u1,
            /// RX buffer not empty interrupt
            /// enable
            RXNEIE: u1,
            /// Tx buffer empty interrupt
            /// enable
            TXEIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x40003808
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Receive buffer not empty
            RXNE: u1,
            /// Transmit buffer empty
            TXE: u1,
            /// Channel side
            CHSIDE: u1,
            /// Underrun flag
            UDR: u1,
            /// CRC error flag
            CRCERR: u1,
            /// Mode fault
            MODF: u1,
            /// Overrun flag
            OVR: u1,
            /// Busy flag
            BSY: u1,
            /// TI frame format error
            TIFRFE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0x8);

        /// address: 0x4000380c
        /// data register
        pub const DR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0xc);

        /// address: 0x40003810
        /// CRC polynomial register
        pub const CRCPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// CRC polynomial register
            CRCPOLY: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x10);

        /// address: 0x40003814
        /// RX CRC register
        pub const RXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rx CRC register
            RxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x14);

        /// address: 0x40003818
        /// TX CRC register
        pub const TXCRCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Tx CRC register
            TxCRC: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4000381c
        /// I2S configuration register
        pub const I2SCFGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel length (number of bits per audio
            /// channel)
            CHLEN: u1,
            /// Data length to be
            /// transferred
            DATLEN: u2,
            /// Steady state clock
            /// polarity
            CKPOL: u1,
            /// I2S standard selection
            I2SSTD: u2,
            reserved0: u1,
            /// PCM frame synchronization
            PCMSYNC: u1,
            /// I2S configuration mode
            I2SCFG: u2,
            /// I2S Enable
            I2SE: u1,
            /// I2S mode selection
            I2SMOD: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x1c);

        /// address: 0x40003820
        /// I2S prescaler register
        pub const I2SPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// I2S Linear prescaler
            I2SDIV: u8,
            /// Odd factor for the
            /// prescaler
            ODD: u1,
            /// Master clock output enable
            MCKOE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x20);
    };

    /// Inter-integrated circuit
    pub const I2C1 = struct {
        pub const base_address = 0x40005400;

        /// address: 0x40005400
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral enable
            PE: u1,
            /// TX Interrupt enable
            TXIE: u1,
            /// RX Interrupt enable
            RXIE: u1,
            /// Address match interrupt enable (slave
            /// only)
            ADDRIE: u1,
            /// Not acknowledge received interrupt
            /// enable
            NACKIE: u1,
            /// STOP detection Interrupt
            /// enable
            STOPIE: u1,
            /// Transfer Complete interrupt
            /// enable
            TCIE: u1,
            /// Error interrupts enable
            ERRIE: u1,
            /// Digital noise filter
            DNF: u4,
            /// Analog noise filter OFF
            ANFOFF: u1,
            reserved0: u1,
            /// DMA transmission requests
            /// enable
            TXDMAEN: u1,
            /// DMA reception requests
            /// enable
            RXDMAEN: u1,
            /// Slave byte control
            SBC: u1,
            /// Clock stretching disable
            NOSTRETCH: u1,
            /// Wakeup from STOP enable
            WUPEN: u1,
            /// General call enable
            GCEN: u1,
            /// SMBus Host address enable
            SMBHEN: u1,
            /// SMBus Device Default address
            /// enable
            SMBDEN: u1,
            /// SMBUS alert enable
            ALERTEN: u1,
            /// PEC enable
            PECEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x0);

        /// address: 0x40005404
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave address bit (master
            /// mode)
            SADD: u10,
            /// Transfer direction (master
            /// mode)
            RD_WRN: u1,
            /// 10-bit addressing mode (master
            /// mode)
            ADD10: u1,
            /// 10-bit address header only read
            /// direction (master receiver mode)
            HEAD10R: u1,
            /// Start generation
            START: u1,
            /// Stop generation (master
            /// mode)
            STOP: u1,
            /// NACK generation (slave
            /// mode)
            NACK: u1,
            /// Number of bytes
            NBYTES: u8,
            /// NBYTES reload mode
            RELOAD: u1,
            /// Automatic end mode (master
            /// mode)
            AUTOEND: u1,
            /// Packet error checking byte
            PECBYTE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x4);

        /// address: 0x40005408
        /// Own address register 1
        pub const OAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interface address
            OA1: u10,
            /// Own Address 1 10-bit mode
            OA1MODE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Own Address 1 enable
            OA1EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000540c
        /// Own address register 2
        pub const OAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Interface address
            OA2: u7,
            /// Own Address 2 masks
            OA2MSK: u3,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Own Address 2 enable
            OA2EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40005410
        /// Timing register
        pub const TIMINGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SCL low period (master
            /// mode)
            SCLL: u8,
            /// SCL high period (master
            /// mode)
            SCLH: u8,
            /// Data hold time
            SDADEL: u4,
            /// Data setup time
            SCLDEL: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Timing prescaler
            PRESC: u4,
        }), base_address + 0x10);

        /// address: 0x40005414
        /// Status register 1
        pub const TIMEOUTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bus timeout A
            TIMEOUTA: u12,
            /// Idle clock timeout
            /// detection
            TIDLE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Clock timeout enable
            TIMOUTEN: u1,
            /// Bus timeout B
            TIMEOUTB: u12,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Extended clock timeout
            /// enable
            TEXTEN: u1,
        }), base_address + 0x14);

        /// address: 0x40005418
        /// Interrupt and Status register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit data register empty
            /// (transmitters)
            TXE: u1,
            /// Transmit interrupt status
            /// (transmitters)
            TXIS: u1,
            /// Receive data register not empty
            /// (receivers)
            RXNE: u1,
            /// Address matched (slave
            /// mode)
            ADDR: u1,
            /// Not acknowledge received
            /// flag
            NACKF: u1,
            /// Stop detection flag
            STOPF: u1,
            /// Transfer Complete (master
            /// mode)
            TC: u1,
            /// Transfer Complete Reload
            TCR: u1,
            /// Bus error
            BERR: u1,
            /// Arbitration lost
            ARLO: u1,
            /// Overrun/Underrun (slave
            /// mode)
            OVR: u1,
            /// PEC Error in reception
            PECERR: u1,
            /// Timeout or t_low detection
            /// flag
            TIMEOUT: u1,
            /// SMBus alert
            ALERT: u1,
            reserved0: u1,
            /// Bus busy
            BUSY: u1,
            /// Transfer direction (Slave
            /// mode)
            DIR: u1,
            /// Address match code (Slave
            /// mode)
            ADDCODE: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x18);

        /// address: 0x4000541c
        /// Interrupt clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Address Matched flag clear
            ADDRCF: u1,
            /// Not Acknowledge flag clear
            NACKCF: u1,
            /// Stop detection flag clear
            STOPCF: u1,
            reserved3: u1,
            reserved4: u1,
            /// Bus error flag clear
            BERRCF: u1,
            /// Arbitration lost flag
            /// clear
            ARLOCF: u1,
            /// Overrun/Underrun flag
            /// clear
            OVRCF: u1,
            /// PEC Error flag clear
            PECCF: u1,
            /// Timeout detection flag
            /// clear
            TIMOUTCF: u1,
            /// Alert flag clear
            ALERTCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x1c);

        /// address: 0x40005420
        /// PEC register
        pub const PECR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Packet error checking
            /// register
            PEC: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x20);

        /// address: 0x40005424
        /// Receive data register
        pub const RXDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8-bit receive data
            RXDATA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x24);

        /// address: 0x40005428
        /// Transmit data register
        pub const TXDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8-bit transmit data
            TXDATA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x28);
    };
    pub const I2C2 = struct {
        pub const base_address = 0x40005800;

        /// address: 0x40005800
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral enable
            PE: u1,
            /// TX Interrupt enable
            TXIE: u1,
            /// RX Interrupt enable
            RXIE: u1,
            /// Address match interrupt enable (slave
            /// only)
            ADDRIE: u1,
            /// Not acknowledge received interrupt
            /// enable
            NACKIE: u1,
            /// STOP detection Interrupt
            /// enable
            STOPIE: u1,
            /// Transfer Complete interrupt
            /// enable
            TCIE: u1,
            /// Error interrupts enable
            ERRIE: u1,
            /// Digital noise filter
            DNF: u4,
            /// Analog noise filter OFF
            ANFOFF: u1,
            reserved0: u1,
            /// DMA transmission requests
            /// enable
            TXDMAEN: u1,
            /// DMA reception requests
            /// enable
            RXDMAEN: u1,
            /// Slave byte control
            SBC: u1,
            /// Clock stretching disable
            NOSTRETCH: u1,
            /// Wakeup from STOP enable
            WUPEN: u1,
            /// General call enable
            GCEN: u1,
            /// SMBus Host address enable
            SMBHEN: u1,
            /// SMBus Device Default address
            /// enable
            SMBDEN: u1,
            /// SMBUS alert enable
            ALERTEN: u1,
            /// PEC enable
            PECEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x0);

        /// address: 0x40005804
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave address bit (master
            /// mode)
            SADD: u10,
            /// Transfer direction (master
            /// mode)
            RD_WRN: u1,
            /// 10-bit addressing mode (master
            /// mode)
            ADD10: u1,
            /// 10-bit address header only read
            /// direction (master receiver mode)
            HEAD10R: u1,
            /// Start generation
            START: u1,
            /// Stop generation (master
            /// mode)
            STOP: u1,
            /// NACK generation (slave
            /// mode)
            NACK: u1,
            /// Number of bytes
            NBYTES: u8,
            /// NBYTES reload mode
            RELOAD: u1,
            /// Automatic end mode (master
            /// mode)
            AUTOEND: u1,
            /// Packet error checking byte
            PECBYTE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x4);

        /// address: 0x40005808
        /// Own address register 1
        pub const OAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interface address
            OA1: u10,
            /// Own Address 1 10-bit mode
            OA1MODE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Own Address 1 enable
            OA1EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000580c
        /// Own address register 2
        pub const OAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Interface address
            OA2: u7,
            /// Own Address 2 masks
            OA2MSK: u3,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Own Address 2 enable
            OA2EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40005810
        /// Timing register
        pub const TIMINGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SCL low period (master
            /// mode)
            SCLL: u8,
            /// SCL high period (master
            /// mode)
            SCLH: u8,
            /// Data hold time
            SDADEL: u4,
            /// Data setup time
            SCLDEL: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Timing prescaler
            PRESC: u4,
        }), base_address + 0x10);

        /// address: 0x40005814
        /// Status register 1
        pub const TIMEOUTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bus timeout A
            TIMEOUTA: u12,
            /// Idle clock timeout
            /// detection
            TIDLE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Clock timeout enable
            TIMOUTEN: u1,
            /// Bus timeout B
            TIMEOUTB: u12,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Extended clock timeout
            /// enable
            TEXTEN: u1,
        }), base_address + 0x14);

        /// address: 0x40005818
        /// Interrupt and Status register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit data register empty
            /// (transmitters)
            TXE: u1,
            /// Transmit interrupt status
            /// (transmitters)
            TXIS: u1,
            /// Receive data register not empty
            /// (receivers)
            RXNE: u1,
            /// Address matched (slave
            /// mode)
            ADDR: u1,
            /// Not acknowledge received
            /// flag
            NACKF: u1,
            /// Stop detection flag
            STOPF: u1,
            /// Transfer Complete (master
            /// mode)
            TC: u1,
            /// Transfer Complete Reload
            TCR: u1,
            /// Bus error
            BERR: u1,
            /// Arbitration lost
            ARLO: u1,
            /// Overrun/Underrun (slave
            /// mode)
            OVR: u1,
            /// PEC Error in reception
            PECERR: u1,
            /// Timeout or t_low detection
            /// flag
            TIMEOUT: u1,
            /// SMBus alert
            ALERT: u1,
            reserved0: u1,
            /// Bus busy
            BUSY: u1,
            /// Transfer direction (Slave
            /// mode)
            DIR: u1,
            /// Address match code (Slave
            /// mode)
            ADDCODE: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x18);

        /// address: 0x4000581c
        /// Interrupt clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Address Matched flag clear
            ADDRCF: u1,
            /// Not Acknowledge flag clear
            NACKCF: u1,
            /// Stop detection flag clear
            STOPCF: u1,
            reserved3: u1,
            reserved4: u1,
            /// Bus error flag clear
            BERRCF: u1,
            /// Arbitration lost flag
            /// clear
            ARLOCF: u1,
            /// Overrun/Underrun flag
            /// clear
            OVRCF: u1,
            /// PEC Error flag clear
            PECCF: u1,
            /// Timeout detection flag
            /// clear
            TIMOUTCF: u1,
            /// Alert flag clear
            ALERTCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x1c);

        /// address: 0x40005820
        /// PEC register
        pub const PECR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Packet error checking
            /// register
            PEC: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x20);

        /// address: 0x40005824
        /// Receive data register
        pub const RXDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8-bit receive data
            RXDATA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x24);

        /// address: 0x40005828
        /// Transmit data register
        pub const TXDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8-bit transmit data
            TXDATA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x28);
    };
    pub const I2C3 = struct {
        pub const base_address = 0x40007800;

        /// address: 0x40007800
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Peripheral enable
            PE: u1,
            /// TX Interrupt enable
            TXIE: u1,
            /// RX Interrupt enable
            RXIE: u1,
            /// Address match interrupt enable (slave
            /// only)
            ADDRIE: u1,
            /// Not acknowledge received interrupt
            /// enable
            NACKIE: u1,
            /// STOP detection Interrupt
            /// enable
            STOPIE: u1,
            /// Transfer Complete interrupt
            /// enable
            TCIE: u1,
            /// Error interrupts enable
            ERRIE: u1,
            /// Digital noise filter
            DNF: u4,
            /// Analog noise filter OFF
            ANFOFF: u1,
            reserved0: u1,
            /// DMA transmission requests
            /// enable
            TXDMAEN: u1,
            /// DMA reception requests
            /// enable
            RXDMAEN: u1,
            /// Slave byte control
            SBC: u1,
            /// Clock stretching disable
            NOSTRETCH: u1,
            /// Wakeup from STOP enable
            WUPEN: u1,
            /// General call enable
            GCEN: u1,
            /// SMBus Host address enable
            SMBHEN: u1,
            /// SMBus Device Default address
            /// enable
            SMBDEN: u1,
            /// SMBUS alert enable
            ALERTEN: u1,
            /// PEC enable
            PECEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x0);

        /// address: 0x40007804
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave address bit (master
            /// mode)
            SADD: u10,
            /// Transfer direction (master
            /// mode)
            RD_WRN: u1,
            /// 10-bit addressing mode (master
            /// mode)
            ADD10: u1,
            /// 10-bit address header only read
            /// direction (master receiver mode)
            HEAD10R: u1,
            /// Start generation
            START: u1,
            /// Stop generation (master
            /// mode)
            STOP: u1,
            /// NACK generation (slave
            /// mode)
            NACK: u1,
            /// Number of bytes
            NBYTES: u8,
            /// NBYTES reload mode
            RELOAD: u1,
            /// Automatic end mode (master
            /// mode)
            AUTOEND: u1,
            /// Packet error checking byte
            PECBYTE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
        }), base_address + 0x4);

        /// address: 0x40007808
        /// Own address register 1
        pub const OAR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interface address
            OA1: u10,
            /// Own Address 1 10-bit mode
            OA1MODE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Own Address 1 enable
            OA1EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000780c
        /// Own address register 2
        pub const OAR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Interface address
            OA2: u7,
            /// Own Address 2 masks
            OA2MSK: u3,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Own Address 2 enable
            OA2EN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0xc);

        /// address: 0x40007810
        /// Timing register
        pub const TIMINGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SCL low period (master
            /// mode)
            SCLL: u8,
            /// SCL high period (master
            /// mode)
            SCLH: u8,
            /// Data hold time
            SDADEL: u4,
            /// Data setup time
            SCLDEL: u4,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Timing prescaler
            PRESC: u4,
        }), base_address + 0x10);

        /// address: 0x40007814
        /// Status register 1
        pub const TIMEOUTR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Bus timeout A
            TIMEOUTA: u12,
            /// Idle clock timeout
            /// detection
            TIDLE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Clock timeout enable
            TIMOUTEN: u1,
            /// Bus timeout B
            TIMEOUTB: u12,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Extended clock timeout
            /// enable
            TEXTEN: u1,
        }), base_address + 0x14);

        /// address: 0x40007818
        /// Interrupt and Status register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Transmit data register empty
            /// (transmitters)
            TXE: u1,
            /// Transmit interrupt status
            /// (transmitters)
            TXIS: u1,
            /// Receive data register not empty
            /// (receivers)
            RXNE: u1,
            /// Address matched (slave
            /// mode)
            ADDR: u1,
            /// Not acknowledge received
            /// flag
            NACKF: u1,
            /// Stop detection flag
            STOPF: u1,
            /// Transfer Complete (master
            /// mode)
            TC: u1,
            /// Transfer Complete Reload
            TCR: u1,
            /// Bus error
            BERR: u1,
            /// Arbitration lost
            ARLO: u1,
            /// Overrun/Underrun (slave
            /// mode)
            OVR: u1,
            /// PEC Error in reception
            PECERR: u1,
            /// Timeout or t_low detection
            /// flag
            TIMEOUT: u1,
            /// SMBus alert
            ALERT: u1,
            reserved0: u1,
            /// Bus busy
            BUSY: u1,
            /// Transfer direction (Slave
            /// mode)
            DIR: u1,
            /// Address match code (Slave
            /// mode)
            ADDCODE: u7,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x18);

        /// address: 0x4000781c
        /// Interrupt clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Address Matched flag clear
            ADDRCF: u1,
            /// Not Acknowledge flag clear
            NACKCF: u1,
            /// Stop detection flag clear
            STOPCF: u1,
            reserved3: u1,
            reserved4: u1,
            /// Bus error flag clear
            BERRCF: u1,
            /// Arbitration lost flag
            /// clear
            ARLOCF: u1,
            /// Overrun/Underrun flag
            /// clear
            OVRCF: u1,
            /// PEC Error flag clear
            PECCF: u1,
            /// Timeout detection flag
            /// clear
            TIMOUTCF: u1,
            /// Alert flag clear
            ALERTCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
        }), base_address + 0x1c);

        /// address: 0x40007820
        /// PEC register
        pub const PECR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Packet error checking
            /// register
            PEC: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x20);

        /// address: 0x40007824
        /// Receive data register
        pub const RXDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8-bit receive data
            RXDATA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x24);

        /// address: 0x40007828
        /// Transmit data register
        pub const TXDR = @intToPtr(*volatile Mmio(32, packed struct {
            /// 8-bit transmit data
            TXDATA: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x28);
    };

    /// Power control
    pub const PWR = struct {
        pub const base_address = 0x40007000;

        /// address: 0x40007000
        /// power control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low-power deep sleep
            LPDS: u1,
            /// Power down deepsleep
            PDDS: u1,
            /// Clear wakeup flag
            CWUF: u1,
            /// Clear standby flag
            CSBF: u1,
            /// Power voltage detector
            /// enable
            PVDE: u1,
            /// PVD level selection
            PLS: u3,
            /// Disable backup domain write
            /// protection
            DBP: u1,
            /// Ultra-low-power mode
            ULP: u1,
            /// Fast wakeup
            FWU: u1,
            /// Voltage scaling range
            /// selection
            VOS: u2,
            /// Deep sleep mode with Flash memory kept
            /// off
            DS_EE_KOFF: u1,
            /// Low power run mode
            LPRUN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x0);

        /// address: 0x40007004
        /// power control/status register
        pub const CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Wakeup flag
            WUF: u1,
            /// Standby flag
            SBF: u1,
            /// PVD output
            PVDO: u1,
            /// Backup regulator ready
            BRR: u1,
            /// Voltage Scaling select
            /// flag
            VOSF: u1,
            /// Regulator LP flag
            REGLPF: u1,
            reserved0: u1,
            reserved1: u1,
            /// Enable WKUP pin
            EWUP: u1,
            /// Backup regulator enable
            BRE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x4);
    };

    /// Flash
    pub const Flash = struct {
        pub const base_address = 0x40022000;

        /// address: 0x40022000
        /// Access control register
        pub const ACR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Latency
            LATENCY: u1,
            /// Prefetch enable
            PRFTEN: u1,
            reserved0: u1,
            /// Flash mode during Sleep
            SLEEP_PD: u1,
            /// Flash mode during Run
            RUN_PD: u1,
            /// Disable Buffer
            DESAB_BUF: u1,
            /// Pre-read data address
            PRE_READ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x0);

        /// address: 0x40022004
        /// Program/erase control register
        pub const PECR = @intToPtr(*volatile Mmio(32, packed struct {
            /// FLASH_PECR and data EEPROM
            /// lock
            PELOCK: u1,
            /// Program memory lock
            PRGLOCK: u1,
            /// Option bytes block lock
            OPTLOCK: u1,
            /// Program memory selection
            PROG: u1,
            /// Data EEPROM selection
            DATA: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Fixed time data write for Byte, Half
            /// Word and Word programming
            FTDW: u1,
            /// Page or Double Word erase
            /// mode
            ERASE: u1,
            /// Half Page/Double Word programming
            /// mode
            FPRG: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Parallel bank mode
            PARALLELBANK: u1,
            /// End of programming interrupt
            /// enable
            EOPIE: u1,
            /// Error interrupt enable
            ERRIE: u1,
            /// Launch the option byte
            /// loading
            OBL_LAUNCH: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x4);

        /// address: 0x40022008
        /// Power down key register
        pub const PDKEYR = @intToPtr(*volatile u32, base_address + 0x8);

        /// address: 0x4002200c
        /// Program/erase key register
        pub const PEKEYR = @intToPtr(*volatile u32, base_address + 0xc);

        /// address: 0x40022010
        /// Program memory key register
        pub const PRGKEYR = @intToPtr(*volatile u32, base_address + 0x10);

        /// address: 0x40022014
        /// Option byte key register
        pub const OPTKEYR = @intToPtr(*volatile u32, base_address + 0x14);

        /// address: 0x40022018
        /// Status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write/erase operations in
            /// progress
            BSY: u1,
            /// End of operation
            EOP: u1,
            /// End of high voltage
            ENDHV: u1,
            /// Flash memory module ready after low
            /// power mode
            READY: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Write protected error
            WRPERR: u1,
            /// Programming alignment
            /// error
            PGAERR: u1,
            /// Size error
            SIZERR: u1,
            /// Option validity error
            OPTVERR: u1,
            reserved4: u1,
            reserved5: u1,
            /// RDERR
            RDERR: u1,
            reserved6: u1,
            /// NOTZEROERR
            NOTZEROERR: u1,
            /// FWWERR
            FWWERR: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
        }), base_address + 0x18);

        /// address: 0x4002201c
        /// Option byte register
        pub const OBR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Read protection
            RDPRT: u8,
            /// Selection of protection mode of WPR
            /// bits
            SPRMOD: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// BOR_LEV
            BOR_LEV: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
        }), base_address + 0x1c);

        /// address: 0x40022020
        /// Write protection register
        pub const WRPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Write protection
            WRP: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x20);
    };

    /// External interrupt/event
    /// controller
    pub const EXTI = struct {
        pub const base_address = 0x40010400;

        /// address: 0x40010400
        /// Interrupt mask register
        /// (EXTI_IMR)
        pub const IMR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Interrupt Mask on line 0
            IM0: u1,
            /// Interrupt Mask on line 1
            IM1: u1,
            /// Interrupt Mask on line 2
            IM2: u1,
            /// Interrupt Mask on line 3
            IM3: u1,
            /// Interrupt Mask on line 4
            IM4: u1,
            /// Interrupt Mask on line 5
            IM5: u1,
            /// Interrupt Mask on line 6
            IM6: u1,
            /// Interrupt Mask on line 7
            IM7: u1,
            /// Interrupt Mask on line 8
            IM8: u1,
            /// Interrupt Mask on line 9
            IM9: u1,
            /// Interrupt Mask on line 10
            IM10: u1,
            /// Interrupt Mask on line 11
            IM11: u1,
            /// Interrupt Mask on line 12
            IM12: u1,
            /// Interrupt Mask on line 13
            IM13: u1,
            /// Interrupt Mask on line 14
            IM14: u1,
            /// Interrupt Mask on line 15
            IM15: u1,
            /// Interrupt Mask on line 16
            IM16: u1,
            /// Interrupt Mask on line 17
            IM17: u1,
            /// Interrupt Mask on line 18
            IM18: u1,
            /// Interrupt Mask on line 19
            IM19: u1,
            /// Interrupt Mask on line 20
            IM20: u1,
            /// Interrupt Mask on line 21
            IM21: u1,
            /// Interrupt Mask on line 22
            IM22: u1,
            /// Interrupt Mask on line 23
            IM23: u1,
            /// Interrupt Mask on line 24
            IM24: u1,
            /// Interrupt Mask on line 25
            IM25: u1,
            /// Interrupt Mask on line 27
            IM26: u1,
            reserved0: u1,
            /// Interrupt Mask on line 27
            IM28: u1,
            /// Interrupt Mask on line 27
            IM29: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x0);

        /// address: 0x40010404
        /// Event mask register (EXTI_EMR)
        pub const EMR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Event Mask on line 0
            EM0: u1,
            /// Event Mask on line 1
            EM1: u1,
            /// Event Mask on line 2
            EM2: u1,
            /// Event Mask on line 3
            EM3: u1,
            /// Event Mask on line 4
            EM4: u1,
            /// Event Mask on line 5
            EM5: u1,
            /// Event Mask on line 6
            EM6: u1,
            /// Event Mask on line 7
            EM7: u1,
            /// Event Mask on line 8
            EM8: u1,
            /// Event Mask on line 9
            EM9: u1,
            /// Event Mask on line 10
            EM10: u1,
            /// Event Mask on line 11
            EM11: u1,
            /// Event Mask on line 12
            EM12: u1,
            /// Event Mask on line 13
            EM13: u1,
            /// Event Mask on line 14
            EM14: u1,
            /// Event Mask on line 15
            EM15: u1,
            /// Event Mask on line 16
            EM16: u1,
            /// Event Mask on line 17
            EM17: u1,
            /// Event Mask on line 18
            EM18: u1,
            /// Event Mask on line 19
            EM19: u1,
            /// Event Mask on line 20
            EM20: u1,
            /// Event Mask on line 21
            EM21: u1,
            /// Event Mask on line 22
            EM22: u1,
            /// Event Mask on line 23
            EM23: u1,
            /// Event Mask on line 24
            EM24: u1,
            /// Event Mask on line 25
            EM25: u1,
            /// Event Mask on line 26
            EM26: u1,
            reserved0: u1,
            /// Event Mask on line 28
            EM28: u1,
            /// Event Mask on line 29
            EM29: u1,
            padding0: u1,
            padding1: u1,
        }), base_address + 0x4);

        /// address: 0x40010408
        /// Rising Trigger selection register
        /// (EXTI_RTSR)
        pub const RTSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Rising trigger event configuration of
            /// line 0
            RT0: u1,
            /// Rising trigger event configuration of
            /// line 1
            RT1: u1,
            /// Rising trigger event configuration of
            /// line 2
            RT2: u1,
            /// Rising trigger event configuration of
            /// line 3
            RT3: u1,
            /// Rising trigger event configuration of
            /// line 4
            RT4: u1,
            /// Rising trigger event configuration of
            /// line 5
            RT5: u1,
            /// Rising trigger event configuration of
            /// line 6
            RT6: u1,
            /// Rising trigger event configuration of
            /// line 7
            RT7: u1,
            /// Rising trigger event configuration of
            /// line 8
            RT8: u1,
            /// Rising trigger event configuration of
            /// line 9
            RT9: u1,
            /// Rising trigger event configuration of
            /// line 10
            RT10: u1,
            /// Rising trigger event configuration of
            /// line 11
            RT11: u1,
            /// Rising trigger event configuration of
            /// line 12
            RT12: u1,
            /// Rising trigger event configuration of
            /// line 13
            RT13: u1,
            /// Rising trigger event configuration of
            /// line 14
            RT14: u1,
            /// Rising trigger event configuration of
            /// line 15
            RT15: u1,
            /// Rising trigger event configuration of
            /// line 16
            RT16: u1,
            /// Rising trigger event configuration of
            /// line 17
            RT17: u1,
            reserved0: u1,
            /// Rising trigger event configuration of
            /// line 19
            RT19: u1,
            /// Rising trigger event configuration of
            /// line 20
            RT20: u1,
            /// Rising trigger event configuration of
            /// line 21
            RT21: u1,
            /// Rising trigger event configuration of
            /// line 22
            RT22: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x8);

        /// address: 0x4001040c
        /// Falling Trigger selection register
        /// (EXTI_FTSR)
        pub const FTSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Falling trigger event configuration of
            /// line 0
            FT0: u1,
            /// Falling trigger event configuration of
            /// line 1
            FT1: u1,
            /// Falling trigger event configuration of
            /// line 2
            FT2: u1,
            /// Falling trigger event configuration of
            /// line 3
            FT3: u1,
            /// Falling trigger event configuration of
            /// line 4
            FT4: u1,
            /// Falling trigger event configuration of
            /// line 5
            FT5: u1,
            /// Falling trigger event configuration of
            /// line 6
            FT6: u1,
            /// Falling trigger event configuration of
            /// line 7
            FT7: u1,
            /// Falling trigger event configuration of
            /// line 8
            FT8: u1,
            /// Falling trigger event configuration of
            /// line 9
            FT9: u1,
            /// Falling trigger event configuration of
            /// line 10
            FT10: u1,
            /// Falling trigger event configuration of
            /// line 11
            FT11: u1,
            /// Falling trigger event configuration of
            /// line 12
            FT12: u1,
            /// Falling trigger event configuration of
            /// line 13
            FT13: u1,
            /// Falling trigger event configuration of
            /// line 14
            FT14: u1,
            /// Falling trigger event configuration of
            /// line 15
            FT15: u1,
            /// Falling trigger event configuration of
            /// line 16
            FT16: u1,
            /// Falling trigger event configuration of
            /// line 17
            FT17: u1,
            reserved0: u1,
            /// Falling trigger event configuration of
            /// line 19
            FT19: u1,
            /// Falling trigger event configuration of
            /// line 20
            FT20: u1,
            /// Falling trigger event configuration of
            /// line 21
            FT21: u1,
            /// Falling trigger event configuration of
            /// line 22
            FT22: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0xc);

        /// address: 0x40010410
        /// Software interrupt event register
        /// (EXTI_SWIER)
        pub const SWIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Software Interrupt on line
            /// 0
            SWI0: u1,
            /// Software Interrupt on line
            /// 1
            SWI1: u1,
            /// Software Interrupt on line
            /// 2
            SWI2: u1,
            /// Software Interrupt on line
            /// 3
            SWI3: u1,
            /// Software Interrupt on line
            /// 4
            SWI4: u1,
            /// Software Interrupt on line
            /// 5
            SWI5: u1,
            /// Software Interrupt on line
            /// 6
            SWI6: u1,
            /// Software Interrupt on line
            /// 7
            SWI7: u1,
            /// Software Interrupt on line
            /// 8
            SWI8: u1,
            /// Software Interrupt on line
            /// 9
            SWI9: u1,
            /// Software Interrupt on line
            /// 10
            SWI10: u1,
            /// Software Interrupt on line
            /// 11
            SWI11: u1,
            /// Software Interrupt on line
            /// 12
            SWI12: u1,
            /// Software Interrupt on line
            /// 13
            SWI13: u1,
            /// Software Interrupt on line
            /// 14
            SWI14: u1,
            /// Software Interrupt on line
            /// 15
            SWI15: u1,
            /// Software Interrupt on line
            /// 16
            SWI16: u1,
            /// Software Interrupt on line
            /// 17
            SWI17: u1,
            reserved0: u1,
            /// Software Interrupt on line
            /// 19
            SWI19: u1,
            /// Software Interrupt on line
            /// 20
            SWI20: u1,
            /// Software Interrupt on line
            /// 21
            SWI21: u1,
            /// Software Interrupt on line
            /// 22
            SWI22: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x10);

        /// address: 0x40010414
        /// Pending register (EXTI_PR)
        pub const PR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Pending bit 0
            PIF0: u1,
            /// Pending bit 1
            PIF1: u1,
            /// Pending bit 2
            PIF2: u1,
            /// Pending bit 3
            PIF3: u1,
            /// Pending bit 4
            PIF4: u1,
            /// Pending bit 5
            PIF5: u1,
            /// Pending bit 6
            PIF6: u1,
            /// Pending bit 7
            PIF7: u1,
            /// Pending bit 8
            PIF8: u1,
            /// Pending bit 9
            PIF9: u1,
            /// Pending bit 10
            PIF10: u1,
            /// Pending bit 11
            PIF11: u1,
            /// Pending bit 12
            PIF12: u1,
            /// Pending bit 13
            PIF13: u1,
            /// Pending bit 14
            PIF14: u1,
            /// Pending bit 15
            PIF15: u1,
            /// Pending bit 16
            PIF16: u1,
            /// Pending bit 17
            PIF17: u1,
            reserved0: u1,
            /// Pending bit 19
            PIF19: u1,
            /// Pending bit 20
            PIF20: u1,
            /// Pending bit 21
            PIF21: u1,
            /// Pending bit 22
            PIF22: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x14);
    };

    /// Analog-to-digital converter
    pub const ADC = struct {
        pub const base_address = 0x40012400;

        /// address: 0x40012400
        /// interrupt and status register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADC ready
            ADRDY: u1,
            /// End of sampling flag
            EOSMP: u1,
            /// End of conversion flag
            EOC: u1,
            /// End of sequence flag
            EOS: u1,
            /// ADC overrun
            OVR: u1,
            reserved0: u1,
            reserved1: u1,
            /// Analog watchdog flag
            AWD: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// End Of Calibration flag
            EOCAL: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x0);

        /// address: 0x40012404
        /// interrupt enable register
        pub const IER = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADC ready interrupt enable
            ADRDYIE: u1,
            /// End of sampling flag interrupt
            /// enable
            EOSMPIE: u1,
            /// End of conversion interrupt
            /// enable
            EOCIE: u1,
            /// End of conversion sequence interrupt
            /// enable
            EOSIE: u1,
            /// Overrun interrupt enable
            OVRIE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Analog watchdog interrupt
            /// enable
            AWDIE: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// End of calibration interrupt
            /// enable
            EOCALIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
        }), base_address + 0x4);

        /// address: 0x40012408
        /// control register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// ADC enable command
            ADEN: u1,
            /// ADC disable command
            ADDIS: u1,
            /// ADC start conversion
            /// command
            ADSTART: u1,
            reserved0: u1,
            /// ADC stop conversion
            /// command
            ADSTP: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            /// ADC Voltage Regulator
            /// Enable
            ADVREGEN: u1,
            reserved24: u1,
            reserved25: u1,
            /// ADC calibration
            ADCAL: u1,
        }), base_address + 0x8);

        /// address: 0x4001240c
        /// configuration register 1
        pub const CFGR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Direct memory access
            /// enable
            DMAEN: u1,
            /// Direct memery access
            /// configuration
            DMACFG: u1,
            /// Scan sequence direction
            SCANDIR: u1,
            /// Data resolution
            RES: u2,
            /// Data alignment
            ALIGN: u1,
            /// External trigger selection
            EXTSEL: u3,
            reserved0: u1,
            /// External trigger enable and polarity
            /// selection
            EXTEN: u2,
            /// Overrun management mode
            OVRMOD: u1,
            /// Single / continuous conversion
            /// mode
            CONT: u1,
            /// Auto-delayed conversion
            /// mode
            AUTDLY: u1,
            /// Auto-off mode
            AUTOFF: u1,
            /// Discontinuous mode
            DISCEN: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// Enable the watchdog on a single channel
            /// or on all channels
            AWDSGL: u1,
            /// Analog watchdog enable
            AWDEN: u1,
            reserved6: u1,
            reserved7: u1,
            /// Analog watchdog channel
            /// selection
            AWDCH: u5,
            padding0: u1,
        }), base_address + 0xc);

        /// address: 0x40012410
        /// configuration register 2
        pub const CFGR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Oversampler Enable
            OVSE: u1,
            reserved0: u1,
            /// Oversampling ratio
            OVSR: u3,
            /// Oversampling shift
            OVSS: u4,
            /// Triggered Oversampling
            TOVS: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            /// ADC clock mode
            CKMODE: u2,
        }), base_address + 0x10);

        /// address: 0x40012414
        /// sampling time register
        pub const SMPR = @intToPtr(*volatile MmioInt(32, u3), base_address + 0x14);

        /// address: 0x40012420
        /// watchdog threshold register
        pub const TR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Analog watchdog lower
            /// threshold
            LT: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Analog watchdog higher
            /// threshold
            HT: u12,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
        }), base_address + 0x20);

        /// address: 0x40012428
        /// channel selection register
        pub const CHSELR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Channel-x selection
            CHSEL0: u1,
            /// Channel-x selection
            CHSEL1: u1,
            /// Channel-x selection
            CHSEL2: u1,
            /// Channel-x selection
            CHSEL3: u1,
            /// Channel-x selection
            CHSEL4: u1,
            /// Channel-x selection
            CHSEL5: u1,
            /// Channel-x selection
            CHSEL6: u1,
            /// Channel-x selection
            CHSEL7: u1,
            /// Channel-x selection
            CHSEL8: u1,
            /// Channel-x selection
            CHSEL9: u1,
            /// Channel-x selection
            CHSEL10: u1,
            /// Channel-x selection
            CHSEL11: u1,
            /// Channel-x selection
            CHSEL12: u1,
            /// Channel-x selection
            CHSEL13: u1,
            /// Channel-x selection
            CHSEL14: u1,
            /// Channel-x selection
            CHSEL15: u1,
            /// Channel-x selection
            CHSEL16: u1,
            /// Channel-x selection
            CHSEL17: u1,
            /// Channel-x selection
            CHSEL18: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
        }), base_address + 0x28);

        /// address: 0x40012440
        /// data register
        pub const DR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Converted data
            DATA: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x40);

        /// address: 0x400124b4
        /// ADC Calibration factor
        pub const CALFACT = @intToPtr(*volatile MmioInt(32, u7), base_address + 0xb4);

        /// address: 0x40012708
        /// ADC common configuration
        /// register
        pub const CCR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            /// ADC prescaler
            PRESC: u4,
            /// VREFINT enable
            VREFEN: u1,
            /// Temperature sensor enable
            TSEN: u1,
            /// VLCD enable
            VLCDEN: u1,
            /// Low Frequency Mode enable
            LFMEN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
        }), base_address + 0x308);
    };

    /// Debug support
    pub const DBG = struct {
        pub const base_address = 0x40015800;

        /// address: 0x40015800
        /// MCU Device ID Code Register
        pub const IDCODE = @intToPtr(*volatile Mmio(32, packed struct {
            /// Device Identifier
            DEV_ID: u12,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Revision Identifier
            REV_ID: u16,
        }), base_address + 0x0);

        /// address: 0x40015804
        /// Debug MCU Configuration
        /// Register
        pub const CR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Debug Sleep Mode
            DBG_SLEEP: u1,
            /// Debug Stop Mode
            DBG_STOP: u1,
            /// Debug Standby Mode
            DBG_STANDBY: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x4);

        /// address: 0x40015808
        /// APB Low Freeze Register
        pub const APB1_FZ = @intToPtr(*volatile Mmio(32, packed struct {
            /// Debug Timer 2 stopped when Core is
            /// halted
            DBG_TIMER2_STOP: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Debug Timer 6 stopped when Core is
            /// halted
            DBG_TIMER6_STOP: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            /// Debug RTC stopped when Core is
            /// halted
            DBG_RTC_STOP: u1,
            /// Debug Window Wachdog stopped when Core
            /// is halted
            DBG_WWDG_STOP: u1,
            /// Debug Independent Wachdog stopped when
            /// Core is halted
            DBG_IWDG_STOP: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// I2C1 SMBUS timeout mode stopped when
            /// core is halted
            DBG_I2C1_STOP: u1,
            /// I2C2 SMBUS timeout mode stopped when
            /// core is halted
            DBG_I2C2_STOP: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            /// LPTIM1 counter stopped when core is
            /// halted
            DBG_LPTIMER_STOP: u1,
        }), base_address + 0x8);

        /// address: 0x4001580c
        /// APB High Freeze Register
        pub const APB2_FZ = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            /// Debug Timer 21 stopped when Core is
            /// halted
            DBG_TIMER21_STOP: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Debug Timer 22 stopped when Core is
            /// halted
            DBG_TIMER22_STO: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0xc);
    };

    /// General-purpose-timers
    pub const TIM2 = struct {
        pub const base_address = 0x40000000;

        /// address: 0x40000000
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            /// Direction
            DIR: u1,
            /// Center-aligned mode
            /// selection
            CMS: u2,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40000004
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/compare DMA
            /// selection
            CCDS: u1,
            /// Master mode selection
            MMS: u3,
            /// TI1 selection
            TI1S: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x40000008
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            reserved0: u1,
            /// Trigger selection
            TS: u3,
            /// Master/Slave mode
            MSM: u1,
            /// External trigger filter
            ETF: u4,
            /// External trigger prescaler
            ETPS: u2,
            /// External clock enable
            ECE: u1,
            /// External trigger polarity
            ETP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000000c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            /// Capture/Compare 2 interrupt
            /// enable
            CC2IE: u1,
            /// Capture/Compare 3 interrupt
            /// enable
            CC3IE: u1,
            /// Capture/Compare 4 interrupt
            /// enable
            CC4IE: u1,
            reserved0: u1,
            /// Trigger interrupt enable
            TIE: u1,
            reserved1: u1,
            /// Update DMA request enable
            UDE: u1,
            /// Capture/Compare 1 DMA request
            /// enable
            CC1DE: u1,
            /// Capture/Compare 2 DMA request
            /// enable
            CC2DE: u1,
            /// Capture/Compare 3 DMA request
            /// enable
            CC3DE: u1,
            /// Capture/Compare 4 DMA request
            /// enable
            CC4DE: u1,
            reserved2: u1,
            /// Trigger DMA request enable
            TDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40000010
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            /// Capture/Compare 2 interrupt
            /// flag
            CC2IF: u1,
            /// Capture/Compare 3 interrupt
            /// flag
            CC3IF: u1,
            /// Capture/Compare 4 interrupt
            /// flag
            CC4IF: u1,
            reserved0: u1,
            /// Trigger interrupt flag
            TIF: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            /// Capture/compare 2 overcapture
            /// flag
            CC2OF: u1,
            /// Capture/Compare 3 overcapture
            /// flag
            CC3OF: u1,
            /// Capture/Compare 4 overcapture
            /// flag
            CC4OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x10);

        /// address: 0x40000014
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            /// Capture/compare 2
            /// generation
            CC2G: u1,
            /// Capture/compare 3
            /// generation
            CC3G: u1,
            /// Capture/compare 4
            /// generation
            CC4G: u1,
            reserved0: u1,
            /// Trigger generation
            TG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x14);

        /// address: 0x40000018
        /// capture/compare mode register 1 (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output compare 1 mode
            OC1M: u3,
            /// Output compare 1 clear
            /// enable
            OC1CE: u1,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Output compare 2 fast
            /// enable
            OC2FE: u1,
            /// Output compare 2 preload
            /// enable
            OC2PE: u1,
            /// Output compare 2 mode
            OC2M: u3,
            /// Output compare 2 clear
            /// enable
            OC2CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40000018
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            IC1PSC: u2,
            /// Input capture 1 filter
            IC1F: u4,
            /// Capture/compare 2
            /// selection
            CC2S: u2,
            /// Input capture 2 prescaler
            IC2PSC: u2,
            /// Input capture 2 filter
            IC2F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4000001c
        /// capture/compare mode register 2 (output
        /// mode)
        pub const CCMR2_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Output compare 3 fast
            /// enable
            OC3FE: u1,
            /// Output compare 3 preload
            /// enable
            OC3PE: u1,
            /// Output compare 3 mode
            OC3M: u3,
            /// Output compare 3 clear
            /// enable
            OC3CE: u1,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Output compare 4 fast
            /// enable
            OC4FE: u1,
            /// Output compare 4 preload
            /// enable
            OC4PE: u1,
            /// Output compare 4 mode
            OC4M: u3,
            /// Output compare 4 clear
            /// enable
            OC4CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x4000001c
        /// capture/compare mode register 2 (input
        /// mode)
        pub const CCMR2_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Input capture 3 prescaler
            IC3PSC: u2,
            /// Input capture 3 filter
            IC3F: u4,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Input capture 4 prescaler
            IC4PSC: u2,
            /// Input capture 4 filter
            IC4F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40000020
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            reserved0: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            /// Capture/Compare 2 output
            /// enable
            CC2E: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2P: u1,
            reserved1: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2NP: u1,
            /// Capture/Compare 3 output
            /// enable
            CC3E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3P: u1,
            reserved2: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3NP: u1,
            /// Capture/Compare 4 output
            /// enable
            CC4E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC4P: u1,
            reserved3: u1,
            /// Capture/Compare 4 output
            /// Polarity
            CC4NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x20);

        /// address: 0x40000024
        /// counter
        pub const CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low counter value
            CNT_L: u16,
            /// High counter value (TIM2
            /// only)
            CNT_H: u16,
        }), base_address + 0x24);

        /// address: 0x40000028
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4000002c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Auto-reload value
            ARR_L: u16,
            /// High Auto-reload value (TIM2
            /// only)
            ARR_H: u16,
        }), base_address + 0x2c);

        /// address: 0x40000034
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare 1
            /// value
            CCR1_L: u16,
            /// High Capture/Compare 1 value (TIM2
            /// only)
            CCR1_H: u16,
        }), base_address + 0x34);

        /// address: 0x40000038
        /// capture/compare register 2
        pub const CCR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare 2
            /// value
            CCR2_L: u16,
            /// High Capture/Compare 2 value (TIM2
            /// only)
            CCR2_H: u16,
        }), base_address + 0x38);

        /// address: 0x4000003c
        /// capture/compare register 3
        pub const CCR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare value
            CCR3_L: u16,
            /// High Capture/Compare value (TIM2
            /// only)
            CCR3_H: u16,
        }), base_address + 0x3c);

        /// address: 0x40000040
        /// capture/compare register 4
        pub const CCR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare value
            CCR4_L: u16,
            /// High Capture/Compare value (TIM2
            /// only)
            CCR4_H: u16,
        }), base_address + 0x40);

        /// address: 0x40000048
        /// DMA control register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA burst length
            DBL: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x48);

        /// address: 0x4000004c
        /// DMA address for full transfer
        pub const DMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA register for burst
            /// accesses
            DMAB: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);

        /// address: 0x40000050
        /// TIM2 option register
        pub const OR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timer2 ETR remap
            ETR_RMP: u3,
            /// Internal trigger
            TI4_RMP: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x50);
    };
    pub const TIM3 = struct {
        pub const base_address = 0x40000400;

        /// address: 0x40000400
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            /// Direction
            DIR: u1,
            /// Center-aligned mode
            /// selection
            CMS: u2,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40000404
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/compare DMA
            /// selection
            CCDS: u1,
            /// Master mode selection
            MMS: u3,
            /// TI1 selection
            TI1S: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x4);

        /// address: 0x40000408
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            reserved0: u1,
            /// Trigger selection
            TS: u3,
            /// Master/Slave mode
            MSM: u1,
            /// External trigger filter
            ETF: u4,
            /// External trigger prescaler
            ETPS: u2,
            /// External clock enable
            ECE: u1,
            /// External trigger polarity
            ETP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4000040c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            /// Capture/Compare 2 interrupt
            /// enable
            CC2IE: u1,
            /// Capture/Compare 3 interrupt
            /// enable
            CC3IE: u1,
            /// Capture/Compare 4 interrupt
            /// enable
            CC4IE: u1,
            reserved0: u1,
            /// Trigger interrupt enable
            TIE: u1,
            reserved1: u1,
            /// Update DMA request enable
            UDE: u1,
            /// Capture/Compare 1 DMA request
            /// enable
            CC1DE: u1,
            /// Capture/Compare 2 DMA request
            /// enable
            CC2DE: u1,
            /// Capture/Compare 3 DMA request
            /// enable
            CC3DE: u1,
            /// Capture/Compare 4 DMA request
            /// enable
            CC4DE: u1,
            reserved2: u1,
            /// Trigger DMA request enable
            TDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0xc);

        /// address: 0x40000410
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            /// Capture/Compare 2 interrupt
            /// flag
            CC2IF: u1,
            /// Capture/Compare 3 interrupt
            /// flag
            CC3IF: u1,
            /// Capture/Compare 4 interrupt
            /// flag
            CC4IF: u1,
            reserved0: u1,
            /// Trigger interrupt flag
            TIF: u1,
            reserved1: u1,
            reserved2: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            /// Capture/compare 2 overcapture
            /// flag
            CC2OF: u1,
            /// Capture/Compare 3 overcapture
            /// flag
            CC3OF: u1,
            /// Capture/Compare 4 overcapture
            /// flag
            CC4OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x10);

        /// address: 0x40000414
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            /// Capture/compare 2
            /// generation
            CC2G: u1,
            /// Capture/compare 3
            /// generation
            CC3G: u1,
            /// Capture/compare 4
            /// generation
            CC4G: u1,
            reserved0: u1,
            /// Trigger generation
            TG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x14);

        /// address: 0x40000418
        /// capture/compare mode register 1 (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output compare 1 mode
            OC1M: u3,
            /// Output compare 1 clear
            /// enable
            OC1CE: u1,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Output compare 2 fast
            /// enable
            OC2FE: u1,
            /// Output compare 2 preload
            /// enable
            OC2PE: u1,
            /// Output compare 2 mode
            OC2M: u3,
            /// Output compare 2 clear
            /// enable
            OC2CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40000418
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            IC1PSC: u2,
            /// Input capture 1 filter
            IC1F: u4,
            /// Capture/compare 2
            /// selection
            CC2S: u2,
            /// Input capture 2 prescaler
            IC2PSC: u2,
            /// Input capture 2 filter
            IC2F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x4000041c
        /// capture/compare mode register 2 (output
        /// mode)
        pub const CCMR2_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Output compare 3 fast
            /// enable
            OC3FE: u1,
            /// Output compare 3 preload
            /// enable
            OC3PE: u1,
            /// Output compare 3 mode
            OC3M: u3,
            /// Output compare 3 clear
            /// enable
            OC3CE: u1,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Output compare 4 fast
            /// enable
            OC4FE: u1,
            /// Output compare 4 preload
            /// enable
            OC4PE: u1,
            /// Output compare 4 mode
            OC4M: u3,
            /// Output compare 4 clear
            /// enable
            OC4CE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x4000041c
        /// capture/compare mode register 2 (input
        /// mode)
        pub const CCMR2_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 3
            /// selection
            CC3S: u2,
            /// Input capture 3 prescaler
            IC3PSC: u2,
            /// Input capture 3 filter
            IC3F: u4,
            /// Capture/Compare 4
            /// selection
            CC4S: u2,
            /// Input capture 4 prescaler
            IC4PSC: u2,
            /// Input capture 4 filter
            IC4F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x1c);

        /// address: 0x40000420
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            reserved0: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            /// Capture/Compare 2 output
            /// enable
            CC2E: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2P: u1,
            reserved1: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2NP: u1,
            /// Capture/Compare 3 output
            /// enable
            CC3E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3P: u1,
            reserved2: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC3NP: u1,
            /// Capture/Compare 4 output
            /// enable
            CC4E: u1,
            /// Capture/Compare 3 output
            /// Polarity
            CC4P: u1,
            reserved3: u1,
            /// Capture/Compare 4 output
            /// Polarity
            CC4NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x20);

        /// address: 0x40000424
        /// counter
        pub const CNT = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low counter value
            CNT_L: u16,
            /// High counter value (TIM2
            /// only)
            CNT_H: u16,
        }), base_address + 0x24);

        /// address: 0x40000428
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4000042c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Auto-reload value
            ARR_L: u16,
            /// High Auto-reload value (TIM2
            /// only)
            ARR_H: u16,
        }), base_address + 0x2c);

        /// address: 0x40000434
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare 1
            /// value
            CCR1_L: u16,
            /// High Capture/Compare 1 value (TIM2
            /// only)
            CCR1_H: u16,
        }), base_address + 0x34);

        /// address: 0x40000438
        /// capture/compare register 2
        pub const CCR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare 2
            /// value
            CCR2_L: u16,
            /// High Capture/Compare 2 value (TIM2
            /// only)
            CCR2_H: u16,
        }), base_address + 0x38);

        /// address: 0x4000043c
        /// capture/compare register 3
        pub const CCR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare value
            CCR3_L: u16,
            /// High Capture/Compare value (TIM2
            /// only)
            CCR3_H: u16,
        }), base_address + 0x3c);

        /// address: 0x40000440
        /// capture/compare register 4
        pub const CCR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Low Capture/Compare value
            CCR4_L: u16,
            /// High Capture/Compare value (TIM2
            /// only)
            CCR4_H: u16,
        }), base_address + 0x40);

        /// address: 0x40000448
        /// DMA control register
        pub const DCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA base address
            DBA: u5,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// DMA burst length
            DBL: u5,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
        }), base_address + 0x48);

        /// address: 0x4000044c
        /// DMA address for full transfer
        pub const DMAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// DMA register for burst
            /// accesses
            DMAB: u16,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x4c);

        /// address: 0x40000450
        /// TIM2 option register
        pub const OR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timer2 ETR remap
            ETR_RMP: u3,
            /// Internal trigger
            TI4_RMP: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x50);
    };

    /// Basic-timers
    pub const TIM6 = struct {
        pub const base_address = 0x40001000;

        /// address: 0x40001000
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Auto-reload preload enable
            ARPE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x40001004
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Master mode selection
            MMS: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x4);

        /// address: 0x4000100c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Update DMA request enable
            UDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0xc);

        /// address: 0x40001010
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x10);

        /// address: 0x40001014
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x14);

        /// address: 0x40001024
        /// counter
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x24);

        /// address: 0x40001028
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4000102c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);
    };
    pub const TIM7 = struct {
        pub const base_address = 0x40001400;

        /// address: 0x40001400
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Auto-reload preload enable
            ARPE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x0);

        /// address: 0x40001404
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Master mode selection
            MMS: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x4);

        /// address: 0x4000140c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Update DMA request enable
            UDE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
        }), base_address + 0xc);

        /// address: 0x40001410
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x10);

        /// address: 0x40001414
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
            padding29: u1,
            padding30: u1,
        }), base_address + 0x14);

        /// address: 0x40001424
        /// counter
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x24);

        /// address: 0x40001428
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4000142c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);
    };

    /// General-purpose-timers
    pub const TIM21 = struct {
        pub const base_address = 0x40010800;

        /// address: 0x40010800
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            /// Direction
            DIR: u1,
            /// Center-aligned mode
            /// selection
            CMS: u2,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40010804
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Master mode selection
            MMS: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x4);

        /// address: 0x40010808
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            reserved0: u1,
            /// Trigger selection
            TS: u3,
            /// Master/Slave mode
            MSM: u1,
            /// External trigger filter
            ETF: u4,
            /// External trigger prescaler
            ETPS: u2,
            /// External clock enable
            ECE: u1,
            /// External trigger polarity
            ETP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4001080c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            /// Capture/Compare 2 interrupt
            /// enable
            CC2IE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Trigger interrupt enable
            TIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0xc);

        /// address: 0x40010810
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            /// Capture/Compare 2 interrupt
            /// flag
            CC2IF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Trigger interrupt flag
            TIF: u1,
            reserved3: u1,
            reserved4: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            /// Capture/compare 2 overcapture
            /// flag
            CC2OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x10);

        /// address: 0x40010814
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            /// Capture/compare 2
            /// generation
            CC2G: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Trigger generation
            TG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x14);

        /// address: 0x40010818
        /// capture/compare mode register (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output Compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output Compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output Compare 1 mode
            OC1M: u3,
            reserved0: u1,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Output Compare 2 fast
            /// enable
            OC2FE: u1,
            /// Output Compare 2 preload
            /// enable
            OC2PE: u1,
            /// Output Compare 2 mode
            OC2M: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x18);

        /// address: 0x40010818
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            IC1PSC: u2,
            /// Input capture 1 filter
            IC1F: u4,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Input capture 2 prescaler
            IC2PSC: u2,
            /// Input capture 2 filter
            IC2F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40010820
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            reserved0: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            /// Capture/Compare 2 output
            /// enable
            CC2E: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2P: u1,
            reserved1: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x20);

        /// address: 0x40010824
        /// counter
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x24);

        /// address: 0x40010828
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4001082c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40010834
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);

        /// address: 0x40010838
        /// capture/compare register 2
        pub const CCR2 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x38);

        /// address: 0x40010850
        /// TIM21 option register
        pub const OR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timer21 ETR remap
            ETR_RMP: u2,
            /// Timer21 TI1
            TI1_RMP: u3,
            /// Timer21 TI2
            TI2_RMP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
        }), base_address + 0x50);
    };

    /// General-purpose-timers
    pub const TIM22 = struct {
        pub const base_address = 0x40011400;

        /// address: 0x40011400
        /// control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            CEN: u1,
            /// Update disable
            UDIS: u1,
            /// Update request source
            URS: u1,
            /// One-pulse mode
            OPM: u1,
            /// Direction
            DIR: u1,
            /// Center-aligned mode
            /// selection
            CMS: u2,
            /// Auto-reload preload enable
            ARPE: u1,
            /// Clock division
            CKD: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x0);

        /// address: 0x40011404
        /// control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// Master mode selection
            MMS: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x4);

        /// address: 0x40011408
        /// slave mode control register
        pub const SMCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Slave mode selection
            SMS: u3,
            reserved0: u1,
            /// Trigger selection
            TS: u3,
            /// Master/Slave mode
            MSM: u1,
            /// External trigger filter
            ETF: u4,
            /// External trigger prescaler
            ETPS: u2,
            /// External clock enable
            ECE: u1,
            /// External trigger polarity
            ETP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x8);

        /// address: 0x4001140c
        /// DMA/Interrupt enable register
        pub const DIER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt enable
            UIE: u1,
            /// Capture/Compare 1 interrupt
            /// enable
            CC1IE: u1,
            /// Capture/Compare 2 interrupt
            /// enable
            CC2IE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Trigger interrupt enable
            TIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0xc);

        /// address: 0x40011410
        /// status register
        pub const SR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update interrupt flag
            UIF: u1,
            /// Capture/compare 1 interrupt
            /// flag
            CC1IF: u1,
            /// Capture/Compare 2 interrupt
            /// flag
            CC2IF: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Trigger interrupt flag
            TIF: u1,
            reserved3: u1,
            reserved4: u1,
            /// Capture/Compare 1 overcapture
            /// flag
            CC1OF: u1,
            /// Capture/compare 2 overcapture
            /// flag
            CC2OF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
        }), base_address + 0x10);

        /// address: 0x40011414
        /// event generation register
        pub const EGR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Update generation
            UG: u1,
            /// Capture/compare 1
            /// generation
            CC1G: u1,
            /// Capture/compare 2
            /// generation
            CC2G: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            /// Trigger generation
            TG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
        }), base_address + 0x14);

        /// address: 0x40011418
        /// capture/compare mode register (output
        /// mode)
        pub const CCMR1_Output = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Output Compare 1 fast
            /// enable
            OC1FE: u1,
            /// Output Compare 1 preload
            /// enable
            OC1PE: u1,
            /// Output Compare 1 mode
            OC1M: u3,
            reserved0: u1,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Output Compare 2 fast
            /// enable
            OC2FE: u1,
            /// Output Compare 2 preload
            /// enable
            OC2PE: u1,
            /// Output Compare 2 mode
            OC2M: u3,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
        }), base_address + 0x18);

        /// address: 0x40011418
        /// capture/compare mode register 1 (input
        /// mode)
        pub const CCMR1_Input = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1
            /// selection
            CC1S: u2,
            /// Input capture 1 prescaler
            IC1PSC: u2,
            /// Input capture 1 filter
            IC1F: u4,
            /// Capture/Compare 2
            /// selection
            CC2S: u2,
            /// Input capture 2 prescaler
            IC2PSC: u2,
            /// Input capture 2 filter
            IC2F: u4,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
        }), base_address + 0x18);

        /// address: 0x40011420
        /// capture/compare enable
        /// register
        pub const CCER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Capture/Compare 1 output
            /// enable
            CC1E: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1P: u1,
            reserved0: u1,
            /// Capture/Compare 1 output
            /// Polarity
            CC1NP: u1,
            /// Capture/Compare 2 output
            /// enable
            CC2E: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2P: u1,
            reserved1: u1,
            /// Capture/Compare 2 output
            /// Polarity
            CC2NP: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x20);

        /// address: 0x40011424
        /// counter
        pub const CNT = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x24);

        /// address: 0x40011428
        /// prescaler
        pub const PSC = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x28);

        /// address: 0x4001142c
        /// auto-reload register
        pub const ARR = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x2c);

        /// address: 0x40011434
        /// capture/compare register 1
        pub const CCR1 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x34);

        /// address: 0x40011438
        /// capture/compare register 2
        pub const CCR2 = @intToPtr(*volatile MmioInt(32, u16), base_address + 0x38);

        /// address: 0x40011450
        /// TIM22 option register
        pub const OR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Timer22 ETR remap
            ETR_RMP: u2,
            /// Timer22 TI1
            TI1_RMP: u2,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x50);
    };

    /// Lower power Universal asynchronous receiver
    /// transmitter
    pub const LPUART1 = struct {
        pub const base_address = 0x40004800;

        /// address: 0x40004800
        /// Control register 1
        pub const CR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// USART enable
            UE: u1,
            /// USART enable in Stop mode
            UESM: u1,
            /// Receiver enable
            RE: u1,
            /// Transmitter enable
            TE: u1,
            /// IDLE interrupt enable
            IDLEIE: u1,
            /// RXNE interrupt enable
            RXNEIE: u1,
            /// Transmission complete interrupt
            /// enable
            TCIE: u1,
            /// interrupt enable
            TXEIE: u1,
            /// PE interrupt enable
            PEIE: u1,
            /// Parity selection
            PS: u1,
            /// Parity control enable
            PCE: u1,
            /// Receiver wakeup method
            WAKE: u1,
            /// Word length
            M0: u1,
            /// Mute mode enable
            MME: u1,
            /// Character match interrupt
            /// enable
            CMIE: u1,
            reserved0: u1,
            /// DEDT0
            DEDT0: u1,
            /// DEDT1
            DEDT1: u1,
            /// DEDT2
            DEDT2: u1,
            /// DEDT3
            DEDT3: u1,
            /// Driver Enable de-assertion
            /// time
            DEDT4: u1,
            /// DEAT0
            DEAT0: u1,
            /// DEAT1
            DEAT1: u1,
            /// DEAT2
            DEAT2: u1,
            /// DEAT3
            DEAT3: u1,
            /// Driver Enable assertion
            /// time
            DEAT4: u1,
            reserved1: u1,
            reserved2: u1,
            /// Word length
            M1: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x0);

        /// address: 0x40004804
        /// Control register 2
        pub const CR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// 7-bit Address Detection/4-bit Address
            /// Detection
            ADDM7: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// Clock enable
            CLKEN: u1,
            /// STOP bits
            STOP: u2,
            reserved10: u1,
            /// Swap TX/RX pins
            SWAP: u1,
            /// RX pin active level
            /// inversion
            RXINV: u1,
            /// TX pin active level
            /// inversion
            TXINV: u1,
            /// Binary data inversion
            TAINV: u1,
            /// Most significant bit first
            MSBFIRST: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            /// Address of the USART node
            ADD0_3: u4,
            /// Address of the USART node
            ADD4_7: u4,
        }), base_address + 0x4);

        /// address: 0x40004808
        /// Control register 3
        pub const CR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// Error interrupt enable
            EIE: u1,
            reserved0: u1,
            reserved1: u1,
            /// Half-duplex selection
            HDSEL: u1,
            reserved2: u1,
            reserved3: u1,
            /// DMA enable receiver
            DMAR: u1,
            /// DMA enable transmitter
            DMAT: u1,
            /// RTS enable
            RTSE: u1,
            /// CTS enable
            CTSE: u1,
            /// CTS interrupt enable
            CTSIE: u1,
            reserved4: u1,
            /// Overrun Disable
            OVRDIS: u1,
            /// DMA Disable on Reception
            /// Error
            DDRE: u1,
            /// Driver enable mode
            DEM: u1,
            /// Driver enable polarity
            /// selection
            DEP: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            /// Wakeup from Stop mode interrupt flag
            /// selection
            WUS: u2,
            /// Wakeup from Stop mode interrupt
            /// enable
            WUFIE: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x8);

        /// address: 0x4000480c
        /// Baud rate register
        pub const BRR = @intToPtr(*volatile MmioInt(32, u20), base_address + 0xc);

        /// address: 0x40004818
        /// Request register
        pub const RQR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// Send break request
            SBKRQ: u1,
            /// Mute mode request
            MMRQ: u1,
            /// Receive data flush request
            RXFRQ: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
        }), base_address + 0x18);

        /// address: 0x4000481c
        /// Interrupt & status
        /// register
        pub const ISR = @intToPtr(*volatile Mmio(32, packed struct {
            /// PE
            PE: u1,
            /// FE
            FE: u1,
            /// NF
            NF: u1,
            /// ORE
            ORE: u1,
            /// IDLE
            IDLE: u1,
            /// RXNE
            RXNE: u1,
            /// TC
            TC: u1,
            /// TXE
            TXE: u1,
            reserved0: u1,
            /// CTSIF
            CTSIF: u1,
            /// CTS
            CTS: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// BUSY
            BUSY: u1,
            /// CMF
            CMF: u1,
            /// SBKF
            SBKF: u1,
            /// RWU
            RWU: u1,
            /// WUF
            WUF: u1,
            /// TEACK
            TEACK: u1,
            /// REACK
            REACK: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
        }), base_address + 0x1c);

        /// address: 0x40004820
        /// Interrupt flag clear register
        pub const ICR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Parity error clear flag
            PECF: u1,
            /// Framing error clear flag
            FECF: u1,
            /// Noise detected clear flag
            NCF: u1,
            /// Overrun error clear flag
            ORECF: u1,
            /// Idle line detected clear
            /// flag
            IDLECF: u1,
            reserved0: u1,
            /// Transmission complete clear
            /// flag
            TCCF: u1,
            reserved1: u1,
            reserved2: u1,
            /// CTS clear flag
            CTSCF: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            /// Character match clear flag
            CMCF: u1,
            reserved10: u1,
            reserved11: u1,
            /// Wakeup from Stop mode clear
            /// flag
            WUCF: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
        }), base_address + 0x20);

        /// address: 0x40004824
        /// Receive data register
        pub const RDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x24);

        /// address: 0x40004828
        /// Transmit data register
        pub const TDR = @intToPtr(*volatile MmioInt(32, u9), base_address + 0x28);
    };

    /// Nested Vectored Interrupt
    /// Controller
    pub const NVIC = struct {
        pub const base_address = 0xe000e100;

        /// address: 0xe000e100
        /// Interrupt Set Enable Register
        pub const ISER = @intToPtr(*volatile Mmio(32, packed struct {
            /// SETENA
            SETENA: u32,
        }), base_address + 0x0);

        /// address: 0xe000e180
        /// Interrupt Clear Enable
        /// Register
        pub const ICER = @intToPtr(*volatile Mmio(32, packed struct {
            /// CLRENA
            CLRENA: u32,
        }), base_address + 0x80);

        /// address: 0xe000e200
        /// Interrupt Set-Pending Register
        pub const ISPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// SETPEND
            SETPEND: u32,
        }), base_address + 0x100);

        /// address: 0xe000e280
        /// Interrupt Clear-Pending
        /// Register
        pub const ICPR = @intToPtr(*volatile Mmio(32, packed struct {
            /// CLRPEND
            CLRPEND: u32,
        }), base_address + 0x180);

        /// address: 0xe000e400
        /// Interrupt Priority Register 0
        pub const IPR0 = @intToPtr(*volatile Mmio(32, packed struct {
            /// priority for interrupt 0
            PRI_0: u8,
            /// priority for interrupt 1
            PRI_1: u8,
            /// priority for interrupt 2
            PRI_2: u8,
            /// priority for interrupt 3
            PRI_3: u8,
        }), base_address + 0x300);

        /// address: 0xe000e404
        /// Interrupt Priority Register 1
        pub const IPR1 = @intToPtr(*volatile Mmio(32, packed struct {
            /// priority for interrupt n
            PRI_4: u8,
            /// priority for interrupt n
            PRI_5: u8,
            /// priority for interrupt n
            PRI_6: u8,
            /// priority for interrupt n
            PRI_7: u8,
        }), base_address + 0x304);

        /// address: 0xe000e408
        /// Interrupt Priority Register 2
        pub const IPR2 = @intToPtr(*volatile Mmio(32, packed struct {
            /// priority for interrupt n
            PRI_8: u8,
            /// priority for interrupt n
            PRI_9: u8,
            /// priority for interrupt n
            PRI_10: u8,
            /// priority for interrupt n
            PRI_11: u8,
        }), base_address + 0x308);

        /// address: 0xe000e40c
        /// Interrupt Priority Register 3
        pub const IPR3 = @intToPtr(*volatile Mmio(32, packed struct {
            /// priority for interrupt n
            PRI_12: u8,
            /// priority for interrupt n
            PRI_13: u8,
            /// priority for interrupt n
            PRI_14: u8,
            /// priority for interrupt n
            PRI_15: u8,
        }), base_address + 0x30c);

        /// address: 0xe000e410
        /// Interrupt Priority Register 4
        pub const IPR4 = @intToPtr(*volatile Mmio(32, packed struct {
            /// priority for interrupt n
            PRI_16: u8,
            /// priority for interrupt n
            PRI_17: u8,
            /// priority for interrupt n
            PRI_18: u8,
            /// priority for interrupt n
            PRI_19: u8,
        }), base_address + 0x310);

        /// address: 0xe000e414
        /// Interrupt Priority Register 5
        pub const IPR5 = @intToPtr(*volatile Mmio(32, packed struct {
            /// priority for interrupt n
            PRI_20: u8,
            /// priority for interrupt n
            PRI_21: u8,
            /// priority for interrupt n
            PRI_22: u8,
            /// priority for interrupt n
            PRI_23: u8,
        }), base_address + 0x314);

        /// address: 0xe000e418
        /// Interrupt Priority Register 6
        pub const IPR6 = @intToPtr(*volatile Mmio(32, packed struct {
            /// priority for interrupt n
            PRI_24: u8,
            /// priority for interrupt n
            PRI_25: u8,
            /// priority for interrupt n
            PRI_26: u8,
            /// priority for interrupt n
            PRI_27: u8,
        }), base_address + 0x318);

        /// address: 0xe000e41c
        /// Interrupt Priority Register 7
        pub const IPR7 = @intToPtr(*volatile Mmio(32, packed struct {
            /// priority for interrupt n
            PRI_28: u8,
            /// priority for interrupt n
            PRI_29: u8,
            /// priority for interrupt n
            PRI_30: u8,
            /// priority for interrupt n
            PRI_31: u8,
        }), base_address + 0x31c);
    };

    /// Memory protection unit
    pub const MPU = struct {
        pub const base_address = 0xe000ed90;

        /// address: 0xe000ed90
        /// MPU type register
        pub const MPU_TYPER = @intToPtr(*volatile Mmio(32, packed struct {
            /// Separate flag
            SEPARATE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Number of MPU data regions
            DREGION: u8,
            /// Number of MPU instruction
            /// regions
            IREGION: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x0);

        /// address: 0xe000ed94
        /// MPU control register
        pub const MPU_CTRL = @intToPtr(*volatile Mmio(32, packed struct {
            /// Enables the MPU
            ENABLE: u1,
            /// Enables the operation of MPU during hard
            /// fault
            HFNMIENA: u1,
            /// Enable priviliged software access to
            /// default memory map
            PRIVDEFENA: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
            padding27: u1,
            padding28: u1,
        }), base_address + 0x4);

        /// address: 0xe000ed98
        /// MPU region number register
        pub const MPU_RNR = @intToPtr(*volatile Mmio(32, packed struct {
            /// MPU region
            REGION: u8,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
        }), base_address + 0x8);

        /// address: 0xe000ed9c
        /// MPU region base address
        /// register
        pub const MPU_RBAR = @intToPtr(*volatile Mmio(32, packed struct {
            /// MPU region field
            REGION: u4,
            /// MPU region number valid
            VALID: u1,
            /// Region base address field
            ADDR: u27,
        }), base_address + 0xc);

        /// address: 0xe000eda0
        /// MPU region attribute and size
        /// register
        pub const MPU_RASR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Region enable bit.
            ENABLE: u1,
            /// Size of the MPU protection
            /// region
            SIZE: u5,
            reserved0: u1,
            reserved1: u1,
            /// Subregion disable bits
            SRD: u8,
            /// memory attribute
            B: u1,
            /// memory attribute
            C: u1,
            /// Shareable memory attribute
            S: u1,
            /// memory attribute
            TEX: u3,
            reserved2: u1,
            reserved3: u1,
            /// Access permission
            AP: u3,
            reserved4: u1,
            /// Instruction access disable
            /// bit
            XN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
        }), base_address + 0x10);
    };

    /// SysTick timer
    pub const STK = struct {
        pub const base_address = 0xe000e010;

        /// address: 0xe000e010
        /// SysTick control and status
        /// register
        pub const CSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Counter enable
            ENABLE: u1,
            /// SysTick exception request
            /// enable
            TICKINT: u1,
            /// Clock source selection
            CLKSOURCE: u1,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// COUNTFLAG
            COUNTFLAG: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
        }), base_address + 0x0);

        /// address: 0xe000e014
        /// SysTick reload value register
        pub const RVR = @intToPtr(*volatile Mmio(32, packed struct {
            /// RELOAD value
            RELOAD: u24,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x4);

        /// address: 0xe000e018
        /// SysTick current value register
        pub const CVR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Current counter value
            CURRENT: u24,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
        }), base_address + 0x8);

        /// address: 0xe000e01c
        /// SysTick calibration value
        /// register
        pub const CALIB = @intToPtr(*volatile Mmio(32, packed struct {
            /// Calibration value
            TENMS: u24,
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            /// SKEW flag: Indicates whether the TENMS
            /// value is exact
            SKEW: u1,
            /// NOREF flag. Reads as zero
            NOREF: u1,
        }), base_address + 0xc);
    };

    /// System control block
    pub const SCB = struct {
        pub const base_address = 0xe000ed00;

        /// address: 0xe000ed00
        /// CPUID base register
        pub const CPUID = @intToPtr(*volatile Mmio(32, packed struct {
            /// Revision number
            Revision: u4,
            /// Part number of the
            /// processor
            PartNo: u12,
            /// Reads as 0xF
            Architecture: u4,
            /// Variant number
            Variant: u4,
            /// Implementer code
            Implementer: u8,
        }), base_address + 0x0);

        /// address: 0xe000ed04
        /// Interrupt control and state
        /// register
        pub const ICSR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Active vector
            VECTACTIVE: u9,
            reserved0: u1,
            reserved1: u1,
            /// Return to base level
            RETTOBASE: u1,
            /// Pending vector
            VECTPENDING: u7,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            /// Interrupt pending flag
            ISRPENDING: u1,
            reserved5: u1,
            reserved6: u1,
            /// SysTick exception clear-pending
            /// bit
            PENDSTCLR: u1,
            /// SysTick exception set-pending
            /// bit
            PENDSTSET: u1,
            /// PendSV clear-pending bit
            PENDSVCLR: u1,
            /// PendSV set-pending bit
            PENDSVSET: u1,
            reserved7: u1,
            reserved8: u1,
            /// NMI set-pending bit.
            NMIPENDSET: u1,
        }), base_address + 0x4);

        /// address: 0xe000ed08
        /// Vector table offset register
        pub const VTOR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            /// Vector table base offset
            /// field
            TBLOFF: u25,
        }), base_address + 0x8);

        /// address: 0xe000ed0c
        /// Application interrupt and reset control
        /// register
        pub const AIRCR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// VECTCLRACTIVE
            VECTCLRACTIVE: u1,
            /// SYSRESETREQ
            SYSRESETREQ: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            /// ENDIANESS
            ENDIANESS: u1,
            /// Register key
            VECTKEYSTAT: u16,
        }), base_address + 0xc);

        /// address: 0xe000ed10
        /// System control register
        pub const SCR = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            /// SLEEPONEXIT
            SLEEPONEXIT: u1,
            /// SLEEPDEEP
            SLEEPDEEP: u1,
            reserved1: u1,
            /// Send Event on Pending bit
            SEVEONPEND: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
            padding22: u1,
            padding23: u1,
            padding24: u1,
            padding25: u1,
            padding26: u1,
        }), base_address + 0x10);

        /// address: 0xe000ed14
        /// Configuration and control
        /// register
        pub const CCR = @intToPtr(*volatile Mmio(32, packed struct {
            /// Configures how the processor enters
            /// Thread mode
            NONBASETHRDENA: u1,
            /// USERSETMPEND
            USERSETMPEND: u1,
            reserved0: u1,
            /// UNALIGN_ TRP
            UNALIGN__TRP: u1,
            /// DIV_0_TRP
            DIV_0_TRP: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            /// BFHFNMIGN
            BFHFNMIGN: u1,
            /// STKALIGN
            STKALIGN: u1,
            padding0: u1,
            padding1: u1,
            padding2: u1,
            padding3: u1,
            padding4: u1,
            padding5: u1,
            padding6: u1,
            padding7: u1,
            padding8: u1,
            padding9: u1,
            padding10: u1,
            padding11: u1,
            padding12: u1,
            padding13: u1,
            padding14: u1,
            padding15: u1,
            padding16: u1,
            padding17: u1,
            padding18: u1,
            padding19: u1,
            padding20: u1,
            padding21: u1,
        }), base_address + 0x14);

        /// address: 0xe000ed1c
        /// System handler priority
        /// registers
        pub const SHPR2 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            reserved16: u1,
            reserved17: u1,
            reserved18: u1,
            reserved19: u1,
            reserved20: u1,
            reserved21: u1,
            reserved22: u1,
            reserved23: u1,
            /// Priority of system handler
            /// 11
            PRI_11: u8,
        }), base_address + 0x1c);

        /// address: 0xe000ed20
        /// System handler priority
        /// registers
        pub const SHPR3 = @intToPtr(*volatile Mmio(32, packed struct {
            reserved0: u1,
            reserved1: u1,
            reserved2: u1,
            reserved3: u1,
            reserved4: u1,
            reserved5: u1,
            reserved6: u1,
            reserved7: u1,
            reserved8: u1,
            reserved9: u1,
            reserved10: u1,
            reserved11: u1,
            reserved12: u1,
            reserved13: u1,
            reserved14: u1,
            reserved15: u1,
            /// Priority of system handler
            /// 14
            PRI_14: u8,
            /// Priority of system handler
            /// 15
            PRI_15: u8,
        }), base_address + 0x20);
    };
};

const std = @import("std");

pub fn mmio(addr: usize, comptime size: u8, comptime PackedT: type) *volatile Mmio(size, PackedT) {
    return @intToPtr(*volatile Mmio(size, PackedT), addr);
}

pub fn Mmio(comptime size: u8, comptime PackedT: type) type {
    if ((size % 8) != 0)
        @compileError("size must be divisible by 8!");

    if (!std.math.isPowerOfTwo(size / 8))
        @compileError("size must encode a power of two number of bytes!");

    const IntT = std.meta.Int(.unsigned, size);

    if (@sizeOf(PackedT) != (size / 8))
        @compileError(std.fmt.comptimePrint("IntT and PackedT must have the same size!, they are {} and {} bytes respectively", .{ size / 8, @sizeOf(PackedT) }));

    return extern struct {
        const Self = @This();

        raw: IntT,

        pub const underlying_type = PackedT;

        pub inline fn read(addr: *volatile Self) PackedT {
            return @bitCast(PackedT, addr.raw);
        }

        pub inline fn write(addr: *volatile Self, val: PackedT) void {
            // This is a workaround for a compiler bug related to miscompilation
            // If the tmp var is not used, result location will fuck things up
            var tmp = @bitCast(IntT, val);
            addr.raw = tmp;
        }

        pub inline fn modify(addr: *volatile Self, fields: anytype) void {
            var val = read(addr);
            inline for (@typeInfo(@TypeOf(fields)).Struct.fields) |field| {
                @field(val, field.name) = @field(fields, field.name);
            }
            write(addr, val);
        }

        pub inline fn toggle(addr: *volatile Self, fields: anytype) void {
            var val = read(addr);
            inline for (@typeInfo(@TypeOf(fields)).Struct.fields) |field| {
                @field(val, @tagName(field.default_value.?)) = !@field(val, @tagName(field.default_value.?));
            }
            write(addr, val);
        }
    };
}

pub fn MmioInt(comptime size: u8, comptime T: type) type {
    return extern struct {
        const Self = @This();

        raw: std.meta.Int(.unsigned, size),

        pub inline fn read(addr: *volatile Self) T {
            return @truncate(T, addr.raw);
        }

        pub inline fn modify(addr: *volatile Self, val: T) void {
            const Int = std.meta.Int(.unsigned, size);
            const mask = ~@as(Int, (1 << @bitSizeOf(T)) - 1);

            var tmp = addr.raw;
            addr.raw = (tmp & mask) | val;
        }
    };
}

pub fn mmioInt(addr: usize, comptime size: usize, comptime T: type) *volatile MmioInt(size, T) {
    return @intToPtr(*volatile MmioInt(size, T), addr);
}

const InterruptVector = extern union {
    C: fn () callconv(.C) void,
    Naked: fn () callconv(.Naked) void,
    // Interrupt is not supported on arm
};

const unhandled = InterruptVector{
    .C = struct {
        fn tmp() callconv(.C) noreturn {
            @panic("unhandled interrupt");
        }
    }.tmp,
};
